<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YG&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oneofai.com/"/>
  <updated>2018-01-15T16:09:03.520Z</updated>
  <id>http://oneofai.com/</id>
  
  <author>
    <name>ONEOFAI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP 详解</title>
    <link href="http://oneofai.com/2018/01/07/2018-01-07-HTTP-detailed/"/>
    <id>http://oneofai.com/2018/01/07/2018-01-07-HTTP-detailed/</id>
    <published>2018-01-06T19:45:32.000Z</published>
    <updated>2018-01-15T16:09:03.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-协议详解"><a href="#HTTP-协议详解" class="headerlink" title="HTTP 协议详解"></a>HTTP 协议详解</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出.</p><a id="more"></a> <p>HTTP协议的主要特点可概括如下:</p><blockquote><ol><li>支持客户/服务器模式</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li></ol></blockquote><h4 id="一、HTTP协议详解之URL篇"><a href="#一、HTTP协议详解之URL篇" class="headerlink" title="一、HTTP协议详解之URL篇"></a>一、HTTP协议详解之URL篇</h4><p>HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用.</p><p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：</p><p><code>http://host[&quot;:&quot;port][abs_path]</code></p><p>HTTP 表示要通过 HTTP 协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成.</p><p>eg:</p><blockquote><p>输入：<code>www.guet.edu.cn</code><br>浏览器自动转换成 <code>http://www.guet.edu.cn/</code></p></blockquote><h4 id="二、HTTP协议详解之请求"><a href="#二、HTTP协议详解之请求" class="headerlink" title="二、HTTP协议详解之请求"></a>二、HTTP协议详解之请求</h4><p>HTTP 请求由三部分组成, 分别是：请求行、消息报头、请求正文</p><ol><li><p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：<br> <br><br> <code>Method</code> : 表示请求方法；<br> <br><br> <code>Request-URI</code> : 统一资源标识符<br> <br><br> <code>HTTP-Version</code> : 表示请求的HTTP协议版本；<br> <br><br> <code>CRLF</code> : 表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）.<br> <br></p><p> 请求方法（所有方法全为大写）有多种，各个方法的解释如下:</p> <table><br>     <tr><br>         <td>GET</td><br>         <td>请求获取Request-URI所标识的资源</td><br>     </tr><br>     <tr><br>         <td>POST</td><br>         <td>在Request-URI所标识的资源后附加新的数据</td><br>     </tr><br>     <tr><br>         <td>HEAD</td><br>         <td>请求获取由Request-URI所标识的资源的响应消息报头</td><br>     </tr><br>     <tr><br>         <td>PUT</td><br>         <td>请求服务器存储一个资源，并用Request-URI作为其标识</td><br>     </tr><br>     <tr><br>         <td>DELETE</td><br>         <td>请求服务器删除Request-URI所标识的资源</td><br>     </tr><br>     <tr><br>         <td>TRACE</td><br>         <td>请求服务器回送收到的请求信息，主要用于测试或诊断</td><br>     </tr><br>     <tr><br>         <td>CONNECT</td><br>         <td>保留将来使用</td><br>     </tr><br>     <tr><br>         <td>OPTIONS</td><br>         <td>请求查询服务器的性能，或者查询与资源相关的选项和需求</td><br>     </tr><br> </table><p> 应用举例:<br> <br><br> GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源<br> <br><br> eg:</p><p> <code>GET /form.html HTTP/1.1 (CRLF)</code></p><p> POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单.<br> <br><br> eg：</p><p> <code>POST /reg.jsp HTTP/ (CRLF) Accept:image/gif,image/x-xbit,... (CRLF) ... HOST:www.guet.edu.cn (CRLF) Content-Length:22 (CRLF) Connection:Keep-Alive (CRLF) Cache-Control:no-cache (CRLF) (CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头 user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</code></p><p> HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的. 利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息. 该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新.</p></li><li><p>请求报头后述</p></li><li>请求正文(略)</li></ol><h4 id="三、HTTP协议详解之响应篇"><a href="#三、HTTP协议详解之响应篇" class="headerlink" title="三、HTTP协议详解之响应篇"></a>三、HTTP协议详解之响应篇</h4><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息.</p><p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p><ol><li><p>状态行格式如下:<br> <br><br> <code>HTTP-Version</code> : 服务器HTTP协议的版本；<br> <br><br> <code>Status-Code</code> : 服务器发回的响应状态代码；<br> <br><br> <code>Reason-Phrase</code> : 状态代码的文本描述<br> <br><br> <code>CRLF</code> : 同上<br> <br></p><p> 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li><p>5xx：服务器端错误–服务器未能实现合法的请求</p><p>常见状态代码、状态描述、说明:</p></li><li><p><code>200 OK</code>      //客户端请求成功</p></li><li><code>400 Bad Request</code>  //客户端请求有语法错误，不能被服务器所理解</li><li><code>401 Unauthorized</code> //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li><code>403 Forbidden</code>  //服务器收到请求，但是拒绝提供服务</li><li><code>404 Not Found</code>  //请求资源不存在，<code>eg：输入了错误的URL</code></li><li><code>500 Internal Server Error</code> //服务器发生不可预期的错误</li><li><p><code>503 Server Unavailable</code>  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><p>eg：<code>HTTP/1.1 200 OK (CRLF)</code></p><p>PS: 具体状态码含义请看<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">这里</a></p></li></ul></li><li>响应报头后述</li><li>响应正文就是服务器返回的资源的内容</li></ol><h4 id="四、HTTP协议详解之消息报头篇"><a href="#四、HTTP协议详解之消息报头篇" class="headerlink" title="四、HTTP协议详解之消息报头篇"></a>四、HTTP协议详解之消息报头篇</h4><p>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成. 请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成.</p><p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头.<br>每一个报头域都是由名字+<code>：</code>+空格+值 组成，消息报头域的名字是大小写无关的.</p><ol><li><p>普通报头</p><p> 在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息.</p><p> eg：</p><ul><li><p>Cache-Control<br><br>用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma.</p><ul><li>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;</li><li>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.<br><br>eg：<br><br>为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：<br><code>response.sehHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);</code><br><br><code>//response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);作用相当于上述代码，通常两者合用</code><br><br>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</li></ul></li><li><p>Date<br><br>普通报头域表示消息产生的日期和时间</p></li><li><p>Connection<br><br>普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p></li></ul></li><li><p>请求报头</p><p> 请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息.</p><p> 常用的请求报头</p><ul><li><p>Accept<br><br>Accept请求报头域用于指定客户端接受哪些类型的信息. <br><br>eg: <code>Accept：image/gif</code>，表明客户端希望接受GIF图象格式的资源；<br><br><code>Accept：text/html</code>，表明客户端希望接受html文本.</p></li><li><p>Accept-Charset<br><br>Accept-Charset请求报头域用于指定客户端接受的字符集.<br><br>eg：<code>Accept-Charset:iso-8859-1,gb2312</code>.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受.</p></li><li><p>Accept-Encoding<br><br>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码.<br><br>eg：<code>Accept-Encoding:gzip.deflate</code>.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受.</p></li><li><p>Accept-Language<br><br>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言.<br><br>eg：<code>Accept-Language:zh-cn</code>.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受.</p></li><li><p>Authorization<br><br>Authorization请求报头域主要用于证明客户端有权查看某个资源. 当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证.</p></li><li><p>Host（发送请求时，该报头域是必需的）<br><br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的.<br><br>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们在浏览器中输入: http://www.guet.edu.cn/index.html</span><br><span class="line">浏览器发送的请求消息中，就会包含Host请求报头域，如下:</span><br><span class="line">Host：www.guet.edu.cn</span><br><span class="line">此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号</span><br></pre></td></tr></table></figure></li><li><p>User-Agent<br><br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息. User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器. 不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了.</p><p>请求报头eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /form.html HTTP/1.1 (CRLF)</span><br><span class="line">Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)</span><br><span class="line">Accept-Language:zh-cn (CRLF)</span><br><span class="line">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class="line">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class="line">If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class="line">Host:www.guet.edu.cn (CRLF)</span><br><span class="line">Connection:Keep-Alive (CRLF)</span><br><span class="line">(CRLF)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>响应报头</p><p> 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息.</p><p> 常用的响应报头</p><ul><li><p>Location<br><br>Location响应报头域用于重定向接受者到一个新的位置. Location响应报头域常用在更换域名的时候.</p></li><li><p>Server<br><br>Server响应报头域包含了服务器用来处理请求的软件信息. 与User-Agent请求报头域是相对应的.</p><p>下面是 Server 响应报头域eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server：Apache-Coyote/1.1</span><br><span class="line">WWW-Authenticate</span><br></pre></td></tr></table></figure><p><code>WWW-Authenticate</code> 响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域.</p><p>eg：<code>WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot;  //可以看出服务器对请求资源采用的是基本验证机制</code></p></li></ul></li><li><p>实体报头</p><p> 请求和响应消息都可以传送一个实体. 一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域. 实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息.</p><p> 常用的实体报头</p><ul><li><p>Content-Encoding<br><br>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制.<br>Content-Encoding这样用于记录文档的压缩方法.<br><br>eg：<code>Content-Encoding：gzip</code></p></li><li><p>Content-Language<br><br>Content-Language实体报头域描述了资源所用的自然语言. 没有设置该域则认为实体内容将提供给所有的语言阅读者.<br><br>eg：<code>Content-Language:da</code></p></li><li><p>Content-Length<br><br>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示</p></li><li><p>Content-Type<br><br>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型.<br><br>eg：<br><br><code>Content-Type:text/html;charset=ISO-8859-1</code><br><br><code>Content-Type:text/html;charset=GB2312</code></p></li><li><p>Last-Modified<br><br>Last-Modified实体报头域用于指示资源的最后修改日期和时间</p></li><li><p>Expires<br><br>Expires实体报头域给出响应过期的日期和时间. 为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间.<br><br>eg：<code>Expires：Thu，15 Sep 2006 16:23:12 GMT</code><br><br>HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期.<br>eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下: <br><code>response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;)</code></p></li></ul></li></ol><h4 id="五、利用telnet观察HTTP协议的通讯过程"><a href="#五、利用telnet观察HTTP协议的通讯过程" class="headerlink" title="五、利用telnet观察HTTP协议的通讯过程"></a>五、利用telnet观察HTTP协议的通讯过程</h4><p>实验目的及原理:</p><p>利用MS的telnet工具，通过手动输入HTTP请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对HTTP协议的通讯过程的认识</p><p>实验步骤：</p><ol><li>打开telnet<ol><li>打开telnet<br>运行–&gt;cmd–&gt;telnet</li><li>打开telnet回显功能<br>set localecho</li></ol></li><li><p>连接服务器并发送请求</p><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open www.guet.edu.cn 80  //注意端口号不能省略</span><br><span class="line">HEAD /index.asp HTTP/1.0</span><br><span class="line">Host:www.guet.edu.cn</span><br><span class="line">/*我们可以变换请求方法,请求桂林电子主页内容,输入消息如下*/</span><br><span class="line">open www.guet.edu.cn 80</span><br><span class="line">GET /index.asp HTTP/1.0  //请求资源的内容</span><br><span class="line">Host:www.guet.edu.cn</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open www.sina.com.cn 80  //在命令提示符号下直接输入telnet www.sina.com.cn 80</span><br><span class="line">HEAD /index.asp HTTP/1.0</span><br><span class="line">Host:www.sina.com.cn</span><br></pre></td></tr></table></figure></li></ol></li><li><p>实验结果:</p><ol><li><p>请求信息2.1得到的响应是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK                                              //请求成功</span><br><span class="line">Server: Microsoft-IIS/5.0                                    //web服务器</span><br><span class="line">Date: Thu,08 Mar 200707:17:51 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 23330</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Expries: Thu,08 Mar 2007 07:16:51 GMT</span><br><span class="line">Set-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/</span><br><span class="line">Cache-control: private</span><br><span class="line">//资源内容省略</span><br></pre></td></tr></table></figure></li><li><p>请求信息<code>2.2</code>得到的响应是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 404 Not Found       //请求失败</span><br><span class="line">Date: Thu, 08 Mar 2007 07:50:50 GMT</span><br><span class="line">Server: Apache/2.0.54 &lt;Unix&gt;</span><br><span class="line">Last-Modified: Thu, 30 Nov 2006 11:35:41 GMT</span><br><span class="line">ETag: &quot;6277a-415-e7c76980&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">X-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remix</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/html</span><br><span class="line">X-Cache: MISS from zjm152-78.sina.com.cn</span><br><span class="line">Via: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;</span><br><span class="line">X-Cache: MISS from th-143.sina.com.cn</span><br><span class="line">Connection: close</span><br><span class="line">失去了跟主机的连接</span><br><span class="line">按任意键继续...</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注意事项：</p><ol><li>出现输入错误，则请求不会成功.</li><li>报头域不分大小写.</li><li>更深一步了解HTTP协议，可以查看<a href="https://www.w3.org/Protocols/HTTP/1.1/rfc2616.pdf" target="_blank" rel="noopener">RFC2616</a>.</li><li>开发后台程序必须掌握HTTP协议.</li></ol></li></ol><h4 id="六、HTTP协议相关技术补充"><a href="#六、HTTP协议相关技术补充" class="headerlink" title="六、HTTP协议相关技术补充"></a>六、HTTP协议相关技术补充</h4><ol><li><p>基础：</p><p> 高层协议有: <br><br> 文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等</p><p> 三种中介: <br><br> <code>Proxy</code> : 代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器.<br><br> <code>Gateway</code> : 网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议.<br><br> <code>Tunnel</code> : 通道作为不改变消息的两个连接之间的中继点. 当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用.</p><ul><li><p>Proxy(代理): 一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求. 请求是通过可能的翻译在内部或经过传递到其它的服务器中. 一个代理在发送请求信息之前，必须解释并且如果可能重写它. 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求.</p></li><li><p>Gateway(网关): 一个作为其它服务器中间媒介的服务器. 与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道. 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源.</p></li><li><p>Tunnel(通道): 是作为两个连接中继的中介程序. 一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的. 当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用.</p></li></ul></li><li><p>协议分析的优势</p><p> HTTP分析器检测网络攻击<br><br> 以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向.<br><br> HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定.</p></li><li><p>HTTP协议Content Lenth限制漏洞导致拒绝服务攻击</p><p> 使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹. <a href="http://www.cnpaf.net/Class/HTTP/200408/80.html" target="_blank" rel="noopener">相关资料</a></p></li><li><p>利用HTTP协议的特性进行拒绝服务攻击的一些构思</p><p> 服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作: 服务器端受到了SYNFlood攻击(SYN洪水攻击).<br><br> 而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的. 本文用“正常连接”的方法来产生拒绝服务攻击.<br></p><p> 19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台 Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个: 1.有Chargen服务 2.有HTTP 服务.</p><p> <code>方法:</code></p><blockquote><p>攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器.</p></blockquote></li><li><p>HTTP指纹识别技术</p><p> HTTP指纹识别的原理大致上也是相同的: 记录不同服务器对HTTP协议执行中的微小差别进行识别. HTTP指纹识别比TCP/IP堆栈指纹识别复杂许多,理由是定制HTTP服务器的配置文件、增加插件或组件使得更改HTTP的响应信息变的很容易, 这样使得识别变的困难；然而定制TCP/IP堆栈的行为需要对核心层进行修改, 所以就容易识别.<br></p><p> 要让服务器返回不同的Banner信息的设置是很简单的,像Apache这样的开放源代码的HTTP服务器,用户可以在源代码里修改Banner信息,然 后重起HTTP服务就生效了；对于没有公开源代码的HTTP服务器比如微软的IIS或者是Netscape, 可以在存放Banner信息的dll文件中修改,相关的文章有讨论的, 这里不再赘述, 当然这样的修改的效果还是不错的. 另外一种模糊Banner信息的方法是使用插件.<br></p><p> 常用测试请求:</p><blockquote><ol><li>HEAD/HTTP/1.0发送基本的HTTP请求</li><li>DELETE/HTTP/1.0发送那些不被允许的请求,比如Delete请求</li><li>GET/HTTP/3.0发送一个非法版本的HTTP协议请求</li><li>GET/JUNK/1.0发送一个不正确规格的HTTP协议请求</li></ol></blockquote><p> HTTP指纹识别工具Httprint, 它通过运用统计学原理, 组合模糊的逻辑学技术, 能很有效的确定Http服务器的类型. 它可以被用来收集和分析不同HTTP服务器产生的签名.</p></li><li><p>其他：</p><p> 为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输.</p><p> HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-协议详解&quot;&gt;&lt;a href=&quot;#HTTP-协议详解&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议详解&quot;&gt;&lt;/a&gt;HTTP 协议详解&lt;/h2&gt;&lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出.&lt;/p&gt;
    
    </summary>
    
      <category term="通信" scheme="http://oneofai.com/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="http://oneofai.com/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="HTTP" scheme="http://oneofai.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>iOS 逆向工程---静态分析</title>
    <link href="http://oneofai.com/2016/10/02/2016-10-02-ios-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    <id>http://oneofai.com/2016/10/02/2016-10-02-ios-逆向工程-静态分析/</id>
    <published>2016-10-02T15:47:35.000Z</published>
    <updated>2018-01-15T16:09:29.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="https://my.oschina.net/iq19900204/blog/340297" target="_blank" rel="noopener">余成海的博客</a></p></blockquote><p>首先学习资料：</p><ul><li><p><a href="http://nianxi.net" target="_blank" rel="noopener">念茜(大神)的博客</a></p></li><li><p><a href="https://item.jd.com/11670145.html" target="_blank" rel="noopener">ios应用逆向工程: 分析与实战</a></p></li></ul><a id="more"></a> <hr><p>其次讲讲要用到的工具(iOS 中的工具在 Cydia 中搜索安装, 有些需要数据源可以自行查找):</p><ul><li><p>已经越狱的iOS设备：这个必须要有</p></li><li><p>OpenSSH (数据源：<a href="http://apt.saurik.com" target="_blank" rel="noopener">http://apt.saurik.com</a>): 用于<code>ssh</code>远程登录和<code>scp</code>文件传输</p></li><li><p>class-dump: 用于简单分析出工程中的类名和函数名</p></li><li><p>IDA：强大的反编译工具</p></li><li><p>Hopper Disassembler：类似IDA 我比较喜欢, 能简单转换成 OC 的伪代码</p></li><li><p>Reveal: UI层解析工具</p></li><li><p>iFunBox、iTools ：两个都是强大的 iOS 设备管理工具, 越狱后能轻松读取应用文件等功能</p></li></ul><hr><p>差不多就这么多了, 上面的工具大部分都是收费的, 不过都是有试用版的, 接下来我们一个个分析:</p><h3 id="1-越狱的-iOS-设备"><a href="#1-越狱的-iOS-设备" class="headerlink" title="1. 越狱的 iOS 设备"></a>1. 越狱的 iOS 设备</h3><p>这个我就不讲了吧, 不过我要赞<a href="http://www.pangu.io/?flag=cn" target="_blank" rel="noopener">盘古团队</a>一个, 目前所有 iOS 系统都可以越狱(包括iOS 8.x)</p><h3 id="2-在-iOS-设备上安装-OpenSSH"><a href="#2-在-iOS-设备上安装-OpenSSH" class="headerlink" title="2. 在 iOS 设备上安装 OpenSSH"></a>2. 在 iOS 设备上安装 OpenSSH</h3><p>数据源: <code>http://apt.saurik.com</code>, 然后用 Mac 远程登录 iOS<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACA80166:~ yuchenghai$ ssh root@172.168.1.100</span><br></pre></td></tr></table></figure></p><p>然后输入密码, <code>@</code>后面是手机的 <code>IP</code>, 越狱后默认密码默认是 <code>123456</code> 或者 <code>alpine</code></p><p>传输文件的命令是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp gdbinit root@172.168.1.100:/var/root</span><br><span class="line">scp root@172.168.1.100:/var/root/123.txt ~/</span><br></pre></td></tr></table></figure></p><h3 id="3-class-dump"><a href="#3-class-dump" class="headerlink" title="3. class-dump"></a>3. <a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump</a></h3><p>class-dump是一个强大的函数提取工具，非常好用，也是基础工具</p><p>可以发到手机里调用, 也可以在电脑上调用, 要解析的文件是在应用目录下 xxx.app (里面还有用到的所有文件资源, xxx是你要分析的应用名), 下面以<code>唱吧</code> 为例, 用 <code>ifunbox</code> 找到应用进入应用目录就可以看到 <code>ktv.app</code> 了打开包文件就能找到ktv<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ class-dump ktv &gt; ktv.txt       //导出所有内容到文件</span><br><span class="line">$ class-dump -H ktv -o ktvdir/   //导出所有内容目录到文件夹(首先要创建ktvdir文件夹)</span><br></pre></td></tr></table></figure></p><p><strong>这里会有一个问题, 就是从app store下载的应用解析出来会是乱码, 因为应用被加密了</strong><br>解决办法</p><ol><li><p>去渠道上下应用, 如同步推、91</p></li><li><p>砸壳, 工具如dumpdecrypted 、 Clutch</p></li></ol><p>class-dump 只能解析出类名和函数名, 不能看到具体的实现逻辑</p><h3 id="4-IDA和Hopper-Disassembler"><a href="#4-IDA和Hopper-Disassembler" class="headerlink" title="4. IDA和Hopper Disassembler"></a>4. <code>IDA</code>和<code>Hopper Disassembler</code></h3><p>这两个差不多, 能看到每个函数的具体逻辑(但是都是汇编) IDA很强大, 能在后面标记的OC的函数名, 但是我更喜欢<code>Hopper Disassembler</code>, 因为他能简单的模拟出OC源码, 但是也是非常简单的. 两者按空格键都能显示出分支逻辑来</p><p>汇编非常难看懂, 我们需要的是<font color="green">耐心+耐心</font>. 后面可以加上动态工具联合分析能更有效</p><h3 id="5-Reveal"><a href="#5-Reveal" class="headerlink" title="5. Reveal"></a>5. <a href="https://revealapp.com/" target="_blank" rel="noopener">Reveal</a></h3><p><code>Reveal</code> 的功能就更强大了, 能分析出 UI 的具体结构来, 告诉你每个 <code>View</code> 的类型是什么, 这通常也是我们常用的分析一个 <code>app</code> 的切入点</p><p>下载完后打开 <code>reveal</code> 在菜单目录中 <code>help-show reveal library in finder</code> 打开库文件, 将两个文件发到手机里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/Reveal.framework root@192.168.0.X:/System/Library/Frameworks</span><br><span class="line">scp /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib root@192.168.0.X:/Library/MobileSubstrate/DynamicLibraries</span><br></pre></td></tr></table></figure><p>接下来编辑 <code>libReveal.plist</code> 文件</p><p>在 <code>/Library/MobileSubstrate/DynamicLibraries/</code> 下创建文件 <code>libReveal.plist</code>, 指定 app 的 Bundle, 可以指定多个<br><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    Filter = &#123;  </span><br><span class="line">         Bundles = ("com.changba.ktv");   </span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同学们会问了, app 的 bundleID 怎么查看呢, 我们还是用 ifunbox 工具找到应用目录, 在xxx.app 文件夹中会有 <code>info.plist</code> 文件, 打开就能找到</p><p>最后重启设备, 打开想分析的应用, 电脑打开reveal接口, 就可以点击分析了</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转自 &lt;a href=&quot;https://my.oschina.net/iq19900204/blog/340297&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;余成海的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先学习资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://nianxi.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;念茜(大神)的博客&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://item.jd.com/11670145.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ios应用逆向工程: 分析与实战&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS 逆向" scheme="http://oneofai.com/categories/iOS-%E9%80%86%E5%90%91/"/>
    
    
      <category term="iOS 逆向" scheme="http://oneofai.com/tags/iOS-%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 逆向工程---ARM汇编</title>
    <link href="http://oneofai.com/2016/09/28/2016-09-28-ios-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-arm%E6%B1%87%E7%BC%96/"/>
    <id>http://oneofai.com/2016/09/28/2016-09-28-ios-逆向工程-arm汇编/</id>
    <published>2016-09-27T16:03:10.000Z</published>
    <updated>2018-01-15T16:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了念茜姐姐的 <a href="http://blog.csdn.net/yiyaaixuexi/article/category/1302847" target="_blank" rel="noopener">iOS 安全攻防</a> 系列, 对逆向产生了兴趣</p><p>遂查了些资料, 这些资料中都涉及到 ARM 汇编, 但都只是很泛地用到, 并没有对 iOS 上的 ARM 汇编进行比较详细的讲解. 因此, 经过一系列的学习对 iOS 下的ARM有了一定的理解. 在此打算用几篇博文记录下来</p><a id="more"></a> <hr><p>我们以ARMV7为例</p><hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote><p>首先介绍一下寄存器:</p></blockquote><p><strong>R0-R3</strong>: 用于函数参数及返回值的传递</p><p><strong>R4-R6, R8, R10-R11</strong>: 没有特殊规定, 就是普通的通用寄存器</p><p><strong>R7</strong>: 栈帧指针(Frame Pointer). 指向前一个保存的栈帧(stack frame)和链接寄存器(link register,  lr)在栈上的地址</p><p><strong>R9</strong>: 操作系统保留</p><p><strong>R12</strong>: IP(intra-procedure scratch ), 要说清楚要费点笔墨, 参见<a href="http://blog.csdn.net/gooogleman/article/details/3529413" target="_blank" rel="noopener">arm 中 r12 的用途</a></p><p><strong>R13</strong>: SP(stack pointer), 是栈顶指针</p><p><strong>R14</strong>: LR(link register), 存放函数的返回地址</p><p><strong>R15</strong>: PC(program counter), 指向当前指令地址</p><p><strong>CPSR</strong>: 当前程序状态寄存器(Current Program State Register), 在用户状态下存放像 condition 标志中断禁用等标志</p><p><code>在其它系统状态中断状等状态下与 CPSR 对应还有一个 SPSR, 这里不详述</code></p><p>另外还有VFP(向量浮点运算)相关的寄存器, 在此我们略过, 感兴趣的可以从后面的参考链接去查看</p><blockquote><p>基本的指令:</p></blockquote><ul><li><p>add :加指令</p></li><li><p>sub :减指令</p></li><li><p>str :把寄存器内容存到栈上去</p></li><li><p>ldr  :把栈上内容载入一寄存器中</p></li><li><p>.w :是一个可选的指令宽度说明符. 它不会影响为此指令的行为, 它只是确保生成 32 位指令. 参见 <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0204ic/ch04s11s01.html" target="_blank" rel="noopener">指令宽度说明符：.W 和 .N</a></p></li><li><p>bl :执行函数调用, 并把使lr指向调用者(caller)的下一条指令, 即函数的返回地址</p></li><li><p>blx :同上, 但是在ARM和thumb指令集间切换</p></li><li><p>bx  :bx lr返回调用函数(caller)</p></li></ul><blockquote><p>函数调用的一些规则</p></blockquote><ol><li><p>在 iOS 中你需要使用 BLX、 BX 这些指令来调用函数, 不能使用 MOV 指令(具体意义下面说)</p></li><li><p>ARM 使用一个栈来来维护函数的调用及返回. ARM 中栈是向下生长(由高地址向低地址生长的)</p></li></ol><p>函数调用前后栈的布局如下图</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fedjryho8cj30f209mq3m.jpg" alt=""></p><p>引用自 <a href="https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html#//apple_ref/doc/uid/TP40009021-SW1" target="_blank" rel="noopener">iOS ABI Reference</a><br>　　　　　　　　　　　　　<br>SP(stack pointer)指向栈顶(栈低在高地址). 栈帧(stack frame)其实就是通过R7及存在栈上的旧R7来标识的栈上的一块一块的存储空间. 栈帧包括:</p><ol><li>参数区域(parameter area), 存放调用函数传递的参数. 对于32位ARM, 前4个参数通过r0-r3传递, 多余的参数通过栈来传递, 就是存放在这个区域的</li><li>链接区域(linkage area), 存放调用者(caller)的下一条指令</li><li>栈帧指针存放区域(saved frame pointer), 存放调用函数的栈帧的底部, 标识着调用者(caller)栈帧的结束及被调用函数(callee)的栈帧开始</li><li>局部变量存储区(local storage area). 用于存被调函数(callee)的局部变量及在被调用函数(callee)结束后反回调用函数(call)之前需要恢复的寄存器内容</li><li>寄存器存储区(saved registers area). Apple的文档中是这样说的. 但我认为这个区域和local storage area相邻且干的事也是存放需要恢复的寄存器内容, 因此我觉得要不就把这个区域在概念上不区分出来, 要不就把存放需要恢复的寄存器这项功能从local storage area中分出来.  当然这些都只是概念上的, 其实实质上是没有区别的</li></ol><blockquote><p>接下来看看在调用子函数开始及结尾时所要做的事情. (官方叫序言和结语, prologs and epilogs)</p></blockquote><ul><li><strong>调用开始:</strong></li></ul><ol><li>LR入栈</li><li>R7入栈</li><li>R7 = SP地址. 在经过前面两条入栈指令后, SP指向的地址向下移动, 再把SP赋值给R7, 标志着caller栈帧的结束及callee的栈帧的开始</li><li>将callee会修改且在返回caller时需要恢复的寄存器入栈</li><li>分配栈空间给子程序使用. 由于栈是从高地址向低地址生长, 所以通常使用sub sp, #size来分配</li></ol><ul><li><strong>调用结尾:</strong></li></ul><ol><li>释放栈空间. add sp, #size指令</li><li>恢复所保存的寄存器</li><li>恢复R7</li><li>将之前存放的LR从栈上弹出到PC, 这样函数就返回了</li></ol><hr><h2 id="实战"><a href="#实战" class="headerlink" title="实战 "></a>实战 <1></1></h2><p>用 Xcode 创建一个 Test 工程, 新建一个 <code>.c</code> 文件, 添加如下函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g = a + b + c + d + e + f;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>注: 在Xcode左上角选中 targe 在真机下编译, 这样产生的才是ARM汇编, 不然在模拟器下生成的是 x86 汇编</code></p><p>点击 Xcode =&gt; Product =&gt; Perform Action =&gt; Assemble filename.c 生成汇编代码</p><p>代码很多, 有很多<code>.</code>开头的, 例如<code>.section</code>、 <code>.loc</code> 等, 这些是汇编器需要的, 我们不用去管. 把这些 <code>.</code> 开头的及注释增掉后, 代码如下:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_func:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">    add r0, r1</span><br><span class="line">Ltmp0:</span><br><span class="line">    ldr.w   r12, [sp]</span><br><span class="line">    add r0, r2</span><br><span class="line">    ldr.w   r9, [sp, #4]</span><br><span class="line">    add r0, r3</span><br><span class="line">    add r0, r12</span><br><span class="line">    add r0, r9</span><br><span class="line">    bx  lr</span><br><span class="line">Ltmp2:</span><br><span class="line">Lfunc_end0:</span><br></pre></td></tr></table></figure><p><code>_func</code>: 表示接下来是 func 函数的内容. <code>Lfunc_begin0</code> 及 <code>Lfunc_end0</code> 标识函数定义的起止. 函数起止一般是 <code>xxx_beginx:</code> 及 <code>xxx_endx:</code></p><p><strong>下面来逐行解释:</strong></p><ul><li><code>add r0, r1</code> :将参数a和参数b相加再把结果赋值给r0</li><li><code>ldr.w r12, [sp]</code> :把最的一个参数f从栈上装载到r12寄存器</li><li><code>add r0, r2</code> :把参数c累加到r0上</li><li><code>ldr.w r9, [sp, #4]</code> :把参数e从栈上装载到r9寄存器</li><li><code>add r0, r3</code> :累加d累加到r0</li><li><code>add r0, r12</code> :累加参数f到r0</li><li><code>add r0, r9</code> :累加参数e到r0</li></ul><p>至此, 全部的 a 到 f 共6个值全部累加到 r0 寄存器上. 前面说了r0是存放返回值的</p><p><code>bx lr</code>: 返回调用函数</p><hr><h2 id="实战-1"><a href="#实战-1" class="headerlink" title="实战 "></a>实战 <2></2></h2><p>为了让大家看清楚函数调用时栈上的变化, 下面有三个函数, 以两个C代码的汇编代码为例讲解一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addFunction</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = a + b + c + d + e + f;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fooFunction</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = addFunction(a, b, c, d, f, <span class="number">66</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = fooFunction(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>);   </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们是要看函数调用及栈的变化的, 所以在这里我们加上<strong>attribute</strong>((noinline))防止编译器把函数内联(如果你不懂内联, 请 Google 之)</p><font color="red">不要忘记选真机编译!</font>   <p>点击 Xcode =&gt; Product =&gt; Perform Action =&gt; Assemble filename.c 生成汇编代码, 如下:</p><p>为了能更符合我们人的思考方式, 我们从调用函数讲起.</p><p>initFunction:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_initFunction:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">Lfunc_begin2:</span><br><span class="line">@ BB#0:</span><br><span class="line">    push    &#123;r7, lr&#125;</span><br><span class="line">    mov r7, sp</span><br><span class="line">    sub sp, #4</span><br><span class="line">    movs    r0, #55</span><br><span class="line">    movs    r1, #22</span><br><span class="line">Ltmp6:</span><br><span class="line">    str r0, [sp]</span><br><span class="line">    movs    r0, #11</span><br><span class="line">    movs    r2, #33</span><br><span class="line">    movs    r3, #44</span><br><span class="line">    bl  _fooFunction</span><br><span class="line">    add sp, #4</span><br><span class="line">    pop &#123;r7, pc&#125;</span><br><span class="line">Ltmp7:</span><br><span class="line">Lfunc_end2:</span><br></pre></td></tr></table></figure><p><strong>逐行解释:</strong></p><ul><li><code>push {r7, lr}</code> :就是前面基础知识部分说的函数调用的序言(prologs)部分的1,  2两条, 将lr, r7 存到栈上去</li><li><code>mov r7, sp</code> :序言(prolog)之3</li><li><code>sub sp, #4</code> :在栈上分配一个4字节空间用来存放局部变量, 即参数. 前面我们说过, r0-r3可以传递4个参数, 但超过的只能通过栈来传递</li><li><code>movs r0, #55</code> :把立即数55存入r0</li><li><code>movs r1, #22</code> :把22存入r1</li><li><code>str r0, [sp]</code> :把r0的值存入栈指针sp指向的内存. 即栈上存了参数55</li><li><code>moves r0, #11</code>、<code>moves r2, #33</code>、<code>moves r3, #44</code> :把相应的立即数存入指定的寄存器. 到目前为止, r0-r3分别存放了11, 22, 33,44共4个立即数参数, 栈上存放了55这一个参数</li><li><code>bl _fooFunction</code> :调用fooFunction, 调用后跳转到fooFunction中的情况下面再分析</li><li><code>add sp, #4</code> :栈指针向上移动4个字节, 回收第3个指令 sub sp, #4分配的空间</li><li><code>pop {r7, pc}</code> :恢复第一条指令 push {r7, lr} 到栈中的值, 把之前的lr值赋给pc<ul><li>注意: 在进入 initFunction 的时候lr是调用 initFunction 的函数的下一条指令, 所以现在把当时的lr中的值赋给pc程序计数器, 这样执行lr指向的这一条指令, 函数就反回了</li></ul></li></ul><p>指令1, 2,  3是函数序言(prologs), 指令9, 10是结语(epilogs). 这基本上是一个套路, 看多了自然就知道了, 都不用停下来一条条分析</p><p>为了方便和栈的变化联系起来, 我们画出指令8,  <code>bl __fooFunction</code>时的栈布局如下图</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fedkzxsr2wj30ac0880t1.jpg" alt=""></p><p>在上面的 <code>initFunction</code> 调用第8条指令 <code>bl _fooFunction</code> 之后, 进入 <code>fooFunction</code>, 其它汇编如下:</p><p>fooFunction:<br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_fooFunction:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">Lfunc_begin1:</span><br><span class="line">    push    &#123;r4, r5, r7, lr&#125;</span><br><span class="line">    add r7, sp, #8</span><br><span class="line">    sub sp, #8</span><br><span class="line">    ldr r4, [r7, #8]</span><br><span class="line">    movs    r5, #66</span><br><span class="line">    strd    r4, r5, [sp]</span><br><span class="line">    bl  _addFunction</span><br><span class="line">    add sp, #8</span><br><span class="line">    pop &#123;r4, r5, r7, pc&#125;</span><br><span class="line">Lfunc_end1:</span><br></pre></td></tr></table></figure></p><p><strong>同样, 我们一行行来看:</strong></p><ul><li><code>push {r4, r5, r7, lr}</code> :你应该发现了, 这次和 initFunction 不同, 除了lr和r7也把r4, r5 push到栈上去了, 这是因为我们下面会用到r4, r5, 所以我们先把r4,r5存到栈上, 这样我们在退出fooFunction返回initFunction的时候好恢复r4, r5的值. push到栈上的顺序是lr, r7, r4, r5</li><li><code>add r7, sp, #8</code> : 在 initFunction 中我们没有 push r4, r5所以sp指向的位置正好是新的r7的值, 但是这里我们把r4, r5也push到栈上了, 现在sp指向栈上的r4的位置, 而栈是向下生长的, 所以我们把sp + #8个字节就是存放旧r7的位置</li><li><code>sub sp, #8</code> :在栈上分配8个字节</li><li><code>ldr r4, [r7, #8]</code> :r7加8个字节, 在栈上的位置正好是在initFunction中我们存放的参数55的位置. 因此, 这里是把55赋值给r4</li><li><code>movs  r5, #66</code> : 立即数赋值, 不解释了</li><li><code>strd r4, r5, [sp]</code> : 把r4, r5中的值存到栈上. 我们在initFunction中已经把11, 22, 33, 44这4个参数存放到了r0-r3, 现在55, 66我们存放在栈上</li><li><code>bl _addFunction</code> :参数已经准备好了, 因此现在调用addFunction</li><li><code>add sp, #8</code> :回收栈空间</li><li><code>pop {r4, r5, r7, pc}</code> :这最后两条指令和 initFunction类似, 只是多了个恢复r4,r5. 不过也是一个指令就完事</li></ul><p>在指令<code>bl _addFunction</code> 调用 <code>addFunction</code> 后, 栈的布局如下图</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1fedl5uolatj30d40e0js5.jpg" alt=""></p><p>上面的 <code>fooFunction</code> 第7条指令 <code>bl _addFunction</code> 之后, 进入 <code>addFunction</code>. 汇编代码如下:</p><p>addFunction:<br><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_addFunction:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">    add r0, r1</span><br><span class="line">    ldr.w   r12, [sp]</span><br><span class="line">    add r0, r2</span><br><span class="line">    ldr.w   r9, [sp, #4]</span><br><span class="line">    add r0, r3</span><br><span class="line">    add r0, r12</span><br><span class="line">    add r0, r9</span><br><span class="line">    bx  lr</span><br><span class="line">Lfunc_end0:</span><br></pre></td></tr></table></figure></p><p><strong>逐行解释:</strong></p><ul><li><code>add r0, r1</code>: r0 += r1</li><li><code>ldr.w r12, [sp]</code> :把sp指向的内容load到r12寄存器. 从上图我们知道sp指向66,因此r12存的66</li><li><code>add r0, r2</code> :r0 += r2</li><li><code>ldr.w r9, [sp, #4]</code> :从上图 sp加4个字节存的是55, r9存的55</li><li><code>add r0, r3</code> :r0 += r3</li><li><code>add r0, r12</code> :r0 += r12</li><li><code>add r0, r9</code> :r0 += r9. 至此r0-r4存的11,22,33,44,及栈上存的55,66想加存到了r0上</li><li><code>bx lr</code> :返回</li></ul><p>大家应该有注意到因为 <code>addFunction</code> 没有调用其它的函数, 序言和结语与 <code>initFunction</code> 和 <code>fooFunction</code> 不一样. 因为我们不调用其它函数, 就不会有<code>bl</code>, <code>blx</code>这样的指令, 所以不会 <code>bx lr</code>, 所以我们没有push lr  </p><hr><p>在这里我们用了r9,  r12, 为什么不需要保存与恢复?</p><p><a href="https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html#//apple_ref/doc/uid/TP40009021-SW1" target="_blank" rel="noopener">iOS ABI Reference</a> 里是这样说的:</p><p>关于R9</p><blockquote><p>In iOS 2.x, register R9 is reserved for operating system use and must not be used by application code. Failure to do so can result in application crashes or aberrant behavior. However, in iOS 3.0 and later, register R9 can be used as a volatile scratch register. These guidelines differ from the general usage provided for by the AAPCS document.  </p></blockquote><p>关于R12</p><blockquote><p>R12 is the intra-procedure scratch register, also known as IP. It is used by the dynamic linker and is volatile across all function calls. However, it can be used as a scratch register between function calls.</p></blockquote><hr><p>参考:<br><a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf" target="_blank" rel="noopener">ARM® and Thumb®-2 Instruction Set<br>Quick Reference Card</a></p><p><a href="http://simplemachines.it/doc/arm_inst.pdf" target="_blank" rel="noopener">The ARM Instruction Set</a></p><p><a href="https://developer.apple.com/library/content/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009020-SW1" target="_blank" rel="noopener">iOS ABI Reference</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了念茜姐姐的 &lt;a href=&quot;http://blog.csdn.net/yiyaaixuexi/article/category/1302847&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS 安全攻防&lt;/a&gt; 系列, 对逆向产生了兴趣&lt;/p&gt;
&lt;p&gt;遂查了些资料, 这些资料中都涉及到 ARM 汇编, 但都只是很泛地用到, 并没有对 iOS 上的 ARM 汇编进行比较详细的讲解. 因此, 经过一系列的学习对 iOS 下的ARM有了一定的理解. 在此打算用几篇博文记录下来&lt;/p&gt;
    
    </summary>
    
      <category term="iOS逆向" scheme="http://oneofai.com/categories/iOS%E9%80%86%E5%90%91/"/>
    
    
      <category term="iOS 逆向" scheme="http://oneofai.com/tags/iOS-%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>关于 NSRunLoop 和 NSTimer 的理解</title>
    <link href="http://oneofai.com/2016/05/11/2016-05-11-%E5%85%B3%E4%BA%8E-nsrunloop-%E5%92%8C-nstimer-%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://oneofai.com/2016/05/11/2016-05-11-关于-nsrunloop-和-nstimer-的理解/</id>
    <published>2016-05-11T13:57:03.000Z</published>
    <updated>2018-01-15T16:13:29.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是NSRunLoop"><a href="#一、什么是NSRunLoop" class="headerlink" title="一、什么是NSRunLoop"></a>一、什么是NSRunLoop</h2><ul><li>NSRunLoop是消息机制的处理模式</li><li>NSRunLoop的作用在于有事情做的时候使的当前NSRunLoop的线程工作, 没有事情做让当前NSRunLoop的线程休眠</li><li>NSTimer默认添加到当前NSRunLoop中, 也可以手动制定添加到自己新建的NSRunLoop</li><li>NSRunLoop就是一直在循环检测, 从线程start到线程end, 检测inputsource(如点击, 双击等操作)同步事件, 检测timesource同步事件, 检测到输入源会执行处理函数, 首先会产生通知, corefunction向线程添加runloop observers来监听事件, 意在监听事件发生时来做处理</li><li>在单线程的app中, 不需要注意Run Loop, 但不代表没有. 程序启动时, 系统已经在主线程中加入了Run Loop. 它保证了我们的主线程在运行起来后, 就处于一种“等待”的状态（而不像一些命令行程序一样运行一次就结束了）, 这个时候如果有接收到的事件（Timer的定时到了或是其他线程的消息）, 就会执行任务, 否则就处于休眠状态</li><li>RunLoopMode是一个集合, 包括监听: 事件源, 定时器, 以及需通知的RunLoop Observers</li></ul><a id="more"></a> <p>RunLoop 模式包括:</p><blockquote><ul><li>default模式: 几乎包括所有输入源(除NSConnection) NSDefaultRunLoopMode模式<br>mode模式: 处理modal panels</li><li>connection模式: 处理NSConnection事件, 属于系统内部, 用户基本不用<br>event tracking模式: 如组件拖动输入源 UITrackingRunLoopModes 不处理定时事件</li><li>common modes模式: NSRunLoopCommonModes 这是一组可配置的通用模式. 将input sources与该模式关联则同时也将input sources与该组中的其它模式进行了关联</li></ul></blockquote><p>每次运行一个run loop, 你指定（显式或隐式）run loop的运行模式. 当相应的模式传递给run loop时, 只有与该模式对应的input sources才被监控并允许run loop对事件进行处理（与此类似, 也只有与该模式对应的observers才会被通知）</p><p>例:</p><blockquote><ol><li>在timer与table同时执行情况, 当拖动table时, runloop进入UITrackingRunLoopModes模式下, 不会处理定时事件, 此时timer不能处理, 所以此时将timer加入到NSRunLoopCommonModes模式(addTimer forMode)   </li><li>在scroll一个页面时来松开, 此时connection不会收到消息, 由于scroll时runloop为UITrackingRunLoopModes模式, 不接收输入源, 此时要修改connection的mode   </li></ol></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop]forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p>关于<code>-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)date;</code>方法   </p><ul><li>指定runloop模式来处理输入源, 首个输入源或date结束退出</li><li>暂停当前处理的流程, 转而处理其他输入源, 当date设置为[NSDate distantFuture]-(将来, 基本不会到达的时间), 所以除非处理其他输入源结束, 否则永不退出处理暂停的当前处理的流程   </li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(A)</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前A为YES时, 当前runloop会一直接收处理其他输入源, 当前流程不继续处理, 出为A为NO, 当前流程继续   </p><p>performSelector关于内存管理的执行原理是这样的执行 <code>[self performSelector:@selector(method1:) withObject:self.tableLayer afterDelay:3];</code> 的时候, 系统会将tableLayer的引用计数加1, 执行完这个方法时, 还会将tableLayer的引用计数减1, 由于延迟这时tableLayer的引用计数没有减少到0, 也就导致了切换场景dealloc方法没有被调用, 出现了内存泄露   </p><p>利用如下函数:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>]</span><br></pre></td></tr></table></figure><p>当然你也可以一个一个得这样用:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(method1:) object:<span class="literal">nil</span>]</span><br></pre></td></tr></table></figure><p>加上了这个以后, 顺利地执行了dealloc方法</p><p>在touchBegan里面<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(longPressMethod:) withObject:<span class="literal">nil</span> afterDelay:longPressTime]</span><br></pre></td></tr></table></figure></p><p>然后在 end 或 cancel 里做判断, 如果时间不够长按的时间调用:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(longPressMethod:) object:<span class="literal">nil</span>]</span><br></pre></td></tr></table></figure></p><p>取消began里的方法   </p><h2 id="二、Run-Loop和线程的关系"><a href="#二、Run-Loop和线程的关系" class="headerlink" title="二、Run Loop和线程的关系:"></a>二、Run Loop和线程的关系:</h2><ol><li><p>主线程的run loop默认是启动的, 用于接收各种输入sources</p></li><li><p>对第二线程来说, run loop默认是没有启动的, 如果你需要更多的线程交互则可以手动配置和启动, 如果线程执行一个长时间已确定的任务则不需要</p></li></ol><h2 id="三、Run-Loop什么情况下使用"><a href="#三、Run-Loop什么情况下使用" class="headerlink" title="三、Run Loop什么情况下使用:"></a>三、Run Loop什么情况下使用:</h2><ul><li>使用ports 或 input sources 和其他线程通信</li><li>在线程中使用timers<code>// 如果不启动run loop, timer的事件不会响应</code></li><li>在 Cocoa 应用中使用<code>performSelector…</code>方法 <code>// performSelector…这种方法会启动一个线程并启动run loop</code></li><li>让线程执行一个周期性的任务</li></ul><p><code>注: timer的创建和释放必须在同一线程中.</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>]; <span class="comment">//此方法会retain timer对象的引用计数</span></span><br></pre></td></tr></table></figure></p><h2 id="四、关于NSTimer"><a href="#四、关于NSTimer" class="headerlink" title="四、关于NSTimer"></a>四、关于NSTimer</h2><h3 id="1-NSTimer会是准时触发事件吗"><a href="#1-NSTimer会是准时触发事件吗" class="headerlink" title="1. NSTimer会是准时触发事件吗"></a>1. NSTimer会是准时触发事件吗</h3><p>答案是否定的, 而且有时候你会发现实际的触发时间跟你想象的差距还比较大. NSTimer不是一个实时系统, 因此不管是一次性的还是周期性的timer的实际触发事件的时间可能都会跟我们预想的会有出入. 差距的大小跟当前我们程序的执行情况有关系, 比如可能程序是多线程的, 而你的timer只是添加在某一个线程的runloop的某一种指定的runloopmode中, 由于多线程通常都是分时执行的, 而且每次执行的mode也可能随着实际情况发生变化</p><p>假设你添加了一个timer指定2秒后触发某一个事件, 但是恰好那个时候当前线程在执行一个连续运算(例如大数据块的处理等), 这个时候timer就会延迟到该连续运算执行完以后才会执行. 重复性的timer遇到这种情况, 如果延迟超过了一个周期, 则会和后面的触发进行合并, 即在一个周期内只会触发一次. 但是不管该timer的触发时间延迟的有多离谱, 他后面的timer的触发时间总是倍数于第一次添加timer的间隙</p><p>原文如下:</p><blockquote><p>A repeating timer reschedules itself based on the scheduled firing time, not the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so far that it passes one or more of the scheduled firing times, the timer is fired only once for that time period; the timer is then rescheduled, after firing, for the next scheduled firing time in the future.</p></blockquote><p>下面请看一个简单的例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    SvTestObject *testObject2 = [[SvTestObject alloc] init];</span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:testObject2 selector:<span class="keyword">@selector</span>(timerAction:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [testObject2 release]; <span class="built_in">NSLog</span>(<span class="string">@"Simulate busy"</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(simulateBusy) withObject:<span class="literal">nil</span> afterDelay:<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟当前线程正好繁忙的情况</span></span><br><span class="line">- (<span class="keyword">void</span>)simulateBusy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start simulate busy!"</span>);</span><br><span class="line">    <span class="built_in">NSUInteger</span> caculateCount = <span class="number">0x0FFFFFFF</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> uselessValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; caculateCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">         uselessValue = i / <span class="number">0.3333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"finish simulate busy!"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>例子中首先开启了一个timer, 这个timer每隔1秒调用一次target的timerAction方法, 紧接着我们在3秒后调用了一个模拟线程繁忙的方法(其实就是一个大的循环)<br>. 运行程序后输出结果如下:</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1febfmejpe6j308c026t8y.jpg" alt=""></p><p>观察结果我们可以发现, 当线程空闲的时候timer的消息触发还是比较准确的, 但是在36分12秒开始线程一直忙着做大量运算, 知道36分14秒该运算才结束, 这个时候timer才触发消息, 这个线程繁忙的过程超过了一个周期, 但是timer并没有连着触发两次消息, 而只是触发了一次. 等线程忙完以后后面的消息触发的时间仍然都是整数倍与开始我们指定的时间, 这也从侧面证明, timer并不会因为触发延迟而导致后面的触发时间发生延迟</p><p><strong>综上: timer不是一种实时的机制, 会存在延迟, 而且延迟的程度跟当前线程的执行情况有关</strong></p><h3 id="2-NSTimer为什么要添加到RunLoop中才会有作用"><a href="#2-NSTimer为什么要添加到RunLoop中才会有作用" class="headerlink" title="2. NSTimer为什么要添加到RunLoop中才会有作用"></a>2. NSTimer为什么要添加到RunLoop中才会有作用</h3><p>前面的例子中我们使用的是一种便利方法, 它其实是做了两件事: 首先创建一个timer, 然后将该timer添加到当前runloop的default mode中. 也就是这个便利方法给我们造成了只要创建了timer就可以生效的错觉, 我们当然可以自己创建timer, 然后手动的把它添加到指定runloop的指定mode中去</p><p>NSTimer其实也是一种资源, 如果看过多线程变成指引文档的话, 我们会发现所有的source如果要起作用, 就得加到runloop中去. 同理timer这种资源要想起作用, 那肯定也需要加到runloop中才会有效喽. 如果一个runloop里面不包含任何资源的话, 运行该runloop时会立马退出. 你可能会说那我们APP的主线程的runloop我们没有往其中添加任何资源, 为什么它还好好的运行. 我们不添加, 不代表框架没有添加, 如果有兴趣的话你可以打印一下main thread的runloop, 你会发现有很多资源</p><p>下面我们看一个小例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> testTimerWithOutShedule];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)testTimerWithOutShedule</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Test timer without shedult to runloop"</span>);</span><br><span class="line">    SvTestObject *testObject3 = [[SvTestObject alloc] init];</span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>] interval:<span class="number">1</span> target:testObject3 selector:<span class="keyword">@selector</span>(timerAction:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [testObject3 release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invoke release to testObject3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"SvTimerSample Will resign Avtive!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个小例子中我们新建了一个timer, 为它指定了有效的target和selector, 并指出了1秒后触发该消息, 运行结果如下:</p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1febfohbg9kj30go02maao.jpg" alt=""></p><p>观察发现这个消息永远也不会触发, 原因很简单, 我们没有将timer添加到runloop中</p><p><strong>综上: 必须得把timer添加到runloop中, 它才会生效</strong></p><h3 id="3-NSTimer加到了RunLoop中但迟迟的不触发事件"><a href="#3-NSTimer加到了RunLoop中但迟迟的不触发事件" class="headerlink" title="3. NSTimer加到了RunLoop中但迟迟的不触发事件"></a>3. NSTimer加到了RunLoop中但迟迟的不触发事件</h3><p>为什么明明添加了, 但是就是不按照预先的逻辑触发事件呢? 原因主要有以下两个:</p><h4 id="1-runloop是否运行"><a href="#1-runloop是否运行" class="headerlink" title="1. runloop是否运行"></a>1. runloop是否运行</h4><p>每一个线程都有它自己的runloop, 程序的主线程会自动的使runloop生效, 但对于我们自己新建的线程, 它的runloop是不会自己运行起来, 当我们需要使用它的runloop时, 就得自己启动</p><p>那么如果我们把一个timer添加到了非主线的runloop中, 它还会按照预期按时触发吗? 下面请看一段测试程序:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(testTimerSheduleToRunloop1) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试把timer加到不运行的runloop上的情况</span></span><br><span class="line">- (<span class="keyword">void</span>)testTimerSheduleToRunloop1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Test timer shedult to a non-running runloop"</span>);</span><br><span class="line">    SvTestObject *testObject4 = [[SvTestObject alloc] init];</span><br><span class="line">    <span class="built_in">NSTimer</span> *timer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>] interval:<span class="number">1</span> target:testObject4 selector:<span class="keyword">@selector</span>(timerAction:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="comment">// 打开下面一行输出runloop的内容就可以看出, timer却是已经被添加进去 //NSLog(@"the thread's runloop: %@",</span></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop]);</span><br><span class="line">    <span class="comment">// 打开下面一行, 该线程的runloop就会运行起来, timer才会起作用</span></span><br><span class="line">    <span class="comment">//[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];</span></span><br><span class="line">    [testObject4 release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invoke release to testObject4"</span>);</span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"SvTimerSample Will resign Avtive!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序中, 我们新创建了一个线程, 然后创建一个timer, 并把它添加当该线程的runloop当中, 但是运行结果如下:</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febfqzd6ghj308c01gmx8.jpg" alt=""></p><p>观察运行结果, 我们发现这个timer知道执行退出也没有触发我们指定的方法, 如果我们把上面测试程序中<code>// \[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];</code> 这一行的注释去掉, 则timer将会正确的调用我们指定的方法</p><h4 id="2-mode是否正确"><a href="#2-mode是否正确" class="headerlink" title="2. mode是否正确"></a>2. mode是否正确</h4><p>我们前面自己动手添加runloop的时候, 可以看到有一个参数runloopMode, 这个参数是干嘛的呢?</p><p>前面提到了要想timer生效, 我们就得把它添加到指定runloop的指定mode中去, 通常是主线程的defalut mode. 但有时我们这样做了, 却仍然发现timer还是没有触发事件. 这是为什么呢?</p><p>这是因为timer添加的时候, 我们需要指定一个mode, 因为同一线程的runloop在运行的时候, 任意时刻只能处于一种mode. 所以只能当程序处于这种mode的时候, timer才能得到触发事件的机会</p><p>举个不恰当的例子, 我们说兄弟几个分别代表runloop的mode, timer代表他们自己的才水桶, 然后一群人去排队打水, 只有一个水龙头, 那么同一时刻, 肯定只能有一个人处于接水的状态. 也就是说你虽然给了老二一个桶, 但是还没轮到它, 那么你就得等, 只有轮到他的时候你的水桶才能碰上用场</p><p><strong>综上: 要让timer生效, 必须保证该线程的runloop已启动, 而且其运行的runloopmode也要匹配</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是NSRunLoop&quot;&gt;&lt;a href=&quot;#一、什么是NSRunLoop&quot; class=&quot;headerlink&quot; title=&quot;一、什么是NSRunLoop&quot;&gt;&lt;/a&gt;一、什么是NSRunLoop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NSRunLoop是消息机制的处理模式&lt;/li&gt;
&lt;li&gt;NSRunLoop的作用在于有事情做的时候使的当前NSRunLoop的线程工作, 没有事情做让当前NSRunLoop的线程休眠&lt;/li&gt;
&lt;li&gt;NSTimer默认添加到当前NSRunLoop中, 也可以手动制定添加到自己新建的NSRunLoop&lt;/li&gt;
&lt;li&gt;NSRunLoop就是一直在循环检测, 从线程start到线程end, 检测inputsource(如点击, 双击等操作)同步事件, 检测timesource同步事件, 检测到输入源会执行处理函数, 首先会产生通知, corefunction向线程添加runloop observers来监听事件, 意在监听事件发生时来做处理&lt;/li&gt;
&lt;li&gt;在单线程的app中, 不需要注意Run Loop, 但不代表没有. 程序启动时, 系统已经在主线程中加入了Run Loop. 它保证了我们的主线程在运行起来后, 就处于一种“等待”的状态（而不像一些命令行程序一样运行一次就结束了）, 这个时候如果有接收到的事件（Timer的定时到了或是其他线程的消息）, 就会执行任务, 否则就处于休眠状态&lt;/li&gt;
&lt;li&gt;RunLoopMode是一个集合, 包括监听: 事件源, 定时器, 以及需通知的RunLoop Observers&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Git 的正确提交姿势</title>
    <link href="http://oneofai.com/2016/02/10/2016-02-10-Git%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>http://oneofai.com/2016/02/10/2016-02-10-Git 的正确使用姿势/</id>
    <published>2016-02-09T18:01:21.000Z</published>
    <updated>2018-01-15T16:13:21.194Z</updated>
    
    <content type="html"><![CDATA[<p>Git 每次提交代码, 都要写 Commit message (提交说明), 否则就不允许提交<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"hello world"</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt; </span><br><span class="line"></span><br><span class="line">上面的命令的`-m`参数, 就是用来指定 commit message 的, 如果一行不够, 可以先 git commit   </span><br><span class="line">```bash</span><br><span class="line">$ git commit</span><br><span class="line">```    </span><br><span class="line">这时会跳出文本编译器, 让你写多行   </span><br><span class="line">![](https://ww2.sinaimg.cn/large/006tNc79ly1feb6kx793yj30z00qudj5.jpg)</span><br><span class="line"></span><br><span class="line">基本上, commit 信息写什么都行, 例如 ([Commit Logs From Last Night](http://www.commitlogsfromlastnight.com/), [Funny initial git commit messages](http://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/) 以及 [fixed errors <span class="keyword">in</span> the previous commit](http://whatthecommit.com/))   </span><br><span class="line"></span><br><span class="line">![](https://ww3.sinaimg.cn/large/006tNc79ly1feb3kz970dj30wk0icacg.jpg)</span><br><span class="line"></span><br><span class="line">但是, 一般来说, commit message 应该清晰明了, 说明本次提交的目的   </span><br><span class="line"></span><br><span class="line">![](https://ww1.sinaimg.cn/large/006tNc79ly1feb7kxw0w7j31380ws7aq.jpg)  </span><br><span class="line"></span><br><span class="line">目前, 社区有多种 Commit message 的[写法规范](https://github.com/ajoslin/conventional-changelog/blob/master/conventions), 此次介绍[Angular 规范](https://gist.github.com/stephenparish/9941e89d80e2bc58a153) ( 见上图 ), 这是目前使用最广的写法, 比较合理和系统化, 并且有配套的工具   </span><br><span class="line"></span><br><span class="line"><span class="comment">### 一、Commit message 的作用   </span></span><br><span class="line">格式化的 Commit message, 有几个好处:   </span><br><span class="line">**1. 提供更多的历史信息，方便快速浏览**   </span><br><span class="line">比如, 下面的命令显示上次发布后的变动, 每个 commit 占据一行. 你只看行首, 就知道某次 commit 的目的</span><br><span class="line">```bash</span><br><span class="line">$ git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure></p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1feb3zu0j8lj30zi0pydmy.jpg" alt=""></p><p><strong>2. 可以过滤某些 commit (比如文档改动), 便于快速查找信息</strong><br>比如, 下面的命令仅仅显示本次发布新增加的功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure></p><p><strong>3. 可以直接从 commit 生成 Change log</strong><br>Change Log 是发布新版本时, 用来说明与上一个版本差异的文档, <a href="#changelog">详见后文</a>   </p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1feb7o6lq0wj315o0h8gov.jpg" alt=""></p><h3 id="二、Commit-message-的格式"><a href="#二、Commit-message-的格式" class="headerlink" title="二、Commit message 的格式"></a>二、Commit message 的格式</h3><p>每次提交, Commit message 都包括三个部分：<code>Header</code>, <code>Body</code> 和 <code>Footer</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中, Header 是必需的, Body 和 Footer 可以省略不管是哪一个部分, 任何一行都不得超过72个字符( 或100个字符 ), 这是为了避免自动换行影响美观   </span><br><span class="line"></span><br><span class="line"><span class="comment">#### 1. Header</span></span><br><span class="line">Header 部分只有一行, 包括三个字段：`<span class="built_in">type</span>`(必需)、`scope`(可选) 和`subject`(必需)   </span><br><span class="line"></span><br><span class="line">**1.1 <span class="built_in">type</span>**   </span><br><span class="line"><span class="built_in">type</span> 用于说明 commit 的类别, 只允许使用下面7个标识</span><br><span class="line"></span><br><span class="line">- feat: 新功能(feature)</span><br><span class="line">- fix: 修补bug</span><br><span class="line">- docs: 文档(documentation)</span><br><span class="line">- style: 格式(不影响代码运行的变动)</span><br><span class="line">- refactor: 重构(即不是新增功能, 也不是修改bug的代码变动)</span><br><span class="line">- <span class="built_in">test</span>: 增加测试</span><br><span class="line">- chore: 构建过程或辅助工具的变动</span><br><span class="line"></span><br><span class="line">如果`<span class="built_in">type</span>`为`feat`和`fix`, 则该 commit 将肯定出现在 `Change <span class="built_in">log</span>` 之中. 其他情况(docs、chore、style、refactor、<span class="built_in">test</span>)由你决定, 要不要放入 Change <span class="built_in">log</span>，建议是不要</span><br><span class="line"></span><br><span class="line">**1.2.scope**   </span><br><span class="line">scope 用于说明 commit 影响的范围, 比如数据层、控制层、视图层等等, 视项目不同而不同   </span><br><span class="line"></span><br><span class="line">**1.3. subject**   </span><br><span class="line">subject 是 commit 目的的简短描述, 不超过50个字符以动词开头, 使用第一人称现在时, 比如 change, 而不是 changed 或 changes 第一个字母小写, 结尾不加句号`.`</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 2. Body</span></span><br><span class="line">Body 部分是对本次 commit 的详细描述, 可以分成多行. 下面是一个范例   </span><br><span class="line">```git</span><br><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to about 72 characters or so.</span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure></p><p>有两个注意点:</p><ol><li>使用第一人称现在时, 比如使用 change, 而不是 changed 或 changes</li><li>应该说明代码变动的动机, 以及与以前行为的对比   </li></ol><h4 id="3-Footer"><a href="#3-Footer" class="headerlink" title="3. Footer"></a>3. Footer</h4><p>Footer 部分只用于两种情况:</p><p><strong>1. 不兼容变动</strong><br>如果当前代码与上一个版本不兼容, 则 Footer 部分以 BREAKING CHANGE 开头, 后面是对变动的描述、以及变动理由和迁移方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed. </span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:    </span><br><span class="line">    Before:    </span><br><span class="line">    scope: &#123;    </span><br><span class="line">      myAttr: &apos;attribute&apos;,    </span><br><span class="line">    &#125;    </span><br><span class="line">    After:    </span><br><span class="line">    scope: &#123;    </span><br><span class="line">      myAttr: &apos;@&apos;,    </span><br><span class="line">    &#125;    </span><br><span class="line">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure></p><p><strong>2. 关闭 Issue</strong><br>如果当前 commit 针对某个issue, 那么可以在 Footer 部分关闭这个 issue<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure></p><p>也可以一次关闭多个 issue<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure></p><h4 id="4-Revert"><a href="#4-Revert" class="headerlink" title="4. Revert"></a>4. Revert</h4><p>还有一种特殊情况, 如果当前 commit 用于撤销以前的 commit, 则必须以<code>revert:</code>开头, 后面跟着被撤销 Commit 的 Header   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 This reverts commit <hash>. 其中的 hash 是被撤销 commit 的 SHA 标识符   </hash></p><p>如果当前 commit 与被撤销的 commit, 在同一个发布版(release)里面, 那么它们都不会出现在 Change log 里面. 如果两者在不同的发布, 那么当前commit, 会出现在 Change log 的 Reverts 小标题下面</p><h3 id="三、Commitizen"><a href="#三、Commitizen" class="headerlink" title="三、Commitizen"></a>三、Commitizen</h3><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a> 是一个撰写合格 Commit message 的工具   </p><p>安装命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure></p><p>然后, 在项目目录里, 运行下面的命令, 使其支持 Angular 的 Commit message 格式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure></p><p>安装了 Commitizen 以后, 凡是用到 git commit 命令, 一律改为使用 git cz .这时, 就会出现选项, 用来生成符合格式的 Commit message</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1feb7u78fx2j315k0gqjuh.jpg" alt=""></p><h3 id="四、validate-commit-msg"><a href="#四、validate-commit-msg" class="headerlink" title="四、validate-commit-msg"></a>四、validate-commit-msg</h3><p><a href="https://github.com/kentcdodds/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a> 用于检查 Node 项目的 Commit message 是否符合格式<br>它的安装是手动的. 首先, 拷贝下面这个<a href="https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js" target="_blank" rel="noopener">JS文件</a>, 放入你的代码库. 文件名可以取为<code>validate-commit-msg.js</code><br>接着, 把这个脚本加入 Git 的 hook. 下面是在 package.json 里面使用 <a href="http://npm.im/ghooks" target="_blank" rel="noopener">ghooks</a>, 把这个脚本加为 commit-msg 时运行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">"config": &#123;  </span><br><span class="line">  "ghooks": &#123;</span><br><span class="line">     "commit-msg": "./validate-commit-msg.js"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，每次 git commit 的时候，这个脚本就会自动检查 Commit message 是否合格. 如果不合格, 就会报错<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -A </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"edit markdown"</span> </span></span><br><span class="line">INVALID COMMIT MSG: does not match "&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;" ! was: edit markdown</span><br></pre></td></tr></table></figure></p><h3 id="五、生成-Change-log"><a href="#五、生成-Change-log" class="headerlink" title="五、生成 Change log"></a><span id="changelog">五、生成 Change log</span></h3><p>如果你的所有 Commit 都符合 Angular 格式, 那么发布新版本时,  Change log 就可以用脚本自动生成(<a href="https://github.com/karma-runner/karma/blob/master/CHANGELOG.md" target="_blank" rel="noopener">例1</a>，<a href="https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md" target="_blank" rel="noopener">例2</a>)   </p><p>生成的文档包括以下三个部分:</p><ul><li>New features</li><li>Bug fixes</li><li>Breaking changes</li></ul><p>每个部分都会罗列相关的 commit, 并且有指向这些 commit 的链接. 当然, 生成的文档允许手动修改, 所以发布前, 你还可以添加其他内容<br><a href="https://github.com/ajoslin/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> 就是生成 Change log 的工具, 运行下面的命令即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g conventional-changelog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> my-project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> conventional-changelog -p angular -i CHANGELOG.md -w</span></span><br></pre></td></tr></table></figure></p><p>上面命令不会覆盖以前的 Change log, 只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动<br>如果你想生成所有发布的 Change log, 要改为运行下面的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure></p><p>为了方便使用, 可以将其写入 package.json 的 scripts 字段<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">     <span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -w -r 0"</span>  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>以后, 直接运行下面的命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run changelog</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 每次提交代码, 都要写 Commit message (提交说明), 否则就不允许提交&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="Git" scheme="http://oneofai.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://oneofai.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>一些著名和非著名的 iOS/Mac 开发博客</title>
    <link href="http://oneofai.com/2015/12/13/2017-07-04-Mac-%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2/"/>
    <id>http://oneofai.com/2015/12/13/2017-07-04-Mac-开发博客/</id>
    <published>2015-12-12T17:04:56.000Z</published>
    <updated>2018-01-15T16:09:12.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自唐巧的 GitHub: <a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="noopener">中文 iOS/Mac 开发博客列表</a></p></blockquote><p>本博客列表涉及的文章内容支持 <a href="https://www.google.com/cse/publicurl?cx=006531766708784105585:e42hjzmqfcu" target="_blank" rel="noopener">定制化Google搜索</a>，特别感谢 <a href="https://github.com/JeOam" target="_blank" rel="noopener">JeOam</a> 提供并帮助更新。</p><p>本博客列表也提供同步更新的OPML文件（<a href="https://github.com/tangqiaoboy/iOSBlogCN/raw/master/blogcn.opml" target="_blank" rel="noopener">下载OPML文件</a>），可供导入到例如feedly/Reeder等第三方定阅工具中，特别感谢 <a href="https://github.com/icepy" target="_blank" rel="noopener">icepy</a> 提供自动转换脚本。这里有<a href="http://blog.feedly.com/feedlimport/" target="_blank" rel="noopener">导入教程</a>。</p><a id="more"></a> <table><thead><tr><th>博客地址</th><th>RSS地址</th></tr></thead><tbody><tr><td><a href="http://onevcat.com" target="_blank" rel="noopener">OneV’s Den</a></td><td><a href="http://onevcat.com/atom.xml" target="_blank" rel="noopener">http://onevcat.com/atom.xml</a></td></tr><tr><td><a href="http://blog.ibireme.com/" target="_blank" rel="noopener">一只魔法师的工坊</a></td><td><a href="http://blog.ibireme.com/feed/" target="_blank" rel="noopener">http://blog.ibireme.com/feed/</a></td></tr><tr><td><a href="http://beyondvincent.com" target="_blank" rel="noopener">破船之家</a></td><td><a href="http://beyondvincent.com/atom.xml" target="_blank" rel="noopener">http://beyondvincent.com/atom.xml</a></td></tr><tr><td><a href="http://nshipster.cn" target="_blank" rel="noopener">NSHipster</a></td><td><a href="http://nshipster.cn/feed.xml" target="_blank" rel="noopener">http://nshipster.cn/feed.xml</a></td></tr><tr><td><a href="http://limboy.me/" target="_blank" rel="noopener">Limboy 无网不剩</a></td><td><a href="http://feeds.feedburner.com/lzyy" target="_blank" rel="noopener">http://feeds.feedburner.com/lzyy</a></td></tr><tr><td><a href="http://blog.devtang.com" target="_blank" rel="noopener">唐巧的技术博客</a></td><td><a href="http://blog.devtang.com/atom.xml" target="_blank" rel="noopener">http://blog.devtang.com/atom.xml</a></td></tr><tr><td><a href="http://wufawei.com/" target="_blank" rel="noopener">Ted’s Homepage</a></td><td><a href="http://wufawei.com/feed" target="_blank" rel="noopener">http://wufawei.com/feed</a></td></tr><tr><td><a href="http://blog.sunnyxx.com/" target="_blank" rel="noopener">sunnyxx的技术博客</a></td><td><a href="http://blog.sunnyxx.com/atom.xml" target="_blank" rel="noopener">http://blog.sunnyxx.com/atom.xml</a></td></tr><tr><td><a href="http://zhowkev.in" target="_blank" rel="noopener">Kevin Blog</a></td><td><a href="http://zhowkev.in/rss" target="_blank" rel="noopener">http://zhowkev.in/rss</a></td></tr><tr><td><a href="http://www.xiangwangfeng.com" target="_blank" rel="noopener">阿毛的蛋疼地</a></td><td><a href="http://www.xiangwangfeng.com/atom.xml" target="_blank" rel="noopener">http://www.xiangwangfeng.com/atom.xml</a></td></tr><tr><td><a href="http://billwang1990.github.io" target="_blank" rel="noopener">亚庆的 Blog</a></td><td><a href="http://billwang1990.github.io/atom.xml" target="_blank" rel="noopener">http://billwang1990.github.io/atom.xml</a></td></tr><tr><td><a href="http://nonomori.farbox.com" target="_blank" rel="noopener">Nonomori</a></td><td><a href="http://nonomori.farbox.com/feed" target="_blank" rel="noopener">http://nonomori.farbox.com/feed</a></td></tr><tr><td><a href="http://wonderffee.github.io" target="_blank" rel="noopener">Wonderffee’s Blog</a></td><td><a href="http://wonderffee.github.io/atom.xml" target="_blank" rel="noopener">http://wonderffee.github.io/atom.xml</a></td></tr><tr><td><a href="http://imtx.me" target="_blank" rel="noopener">I’m TualatriX</a></td><td><a href="http://imtx.me/feed/latest/" target="_blank" rel="noopener">http://imtx.me/feed/latest/</a></td></tr><tr><td><a href="http://blog.cocoabit.com" target="_blank" rel="noopener">Cocoabit</a></td><td><a href="http://blog.cocoabit.com/rss/" target="_blank" rel="noopener">http://blog.cocoabit.com/rss/</a></td></tr><tr><td><a href="http://studentdeng.github.io" target="_blank" rel="noopener">不会开机的男孩</a></td><td><a href="http://studentdeng.github.io/atom.xml" target="_blank" rel="noopener">http://studentdeng.github.io/atom.xml</a></td></tr><tr><td><a href="http://blog.inico.me" target="_blank" rel="noopener">Nico</a></td><td><a href="http://blog.inico.me/atom.xml" target="_blank" rel="noopener">http://blog.inico.me/atom.xml</a></td></tr><tr><td><a href="http://hufeng825.github.io" target="_blank" rel="noopener">阿峰的技术窝窝</a></td><td><a href="http://hufeng825.github.io/atom.xml" target="_blank" rel="noopener">http://hufeng825.github.io/atom.xml</a></td></tr><tr><td><a href="http://answerhuang.duapp.com" target="_blank" rel="noopener">answer_huang</a></td><td><a href="http://answerhuang.duapp.com/index.php/feed/" target="_blank" rel="noopener">http://answerhuang.duapp.com/index.php/feed/</a></td></tr><tr><td><a href="http://blog.nswebfrog.com/" target="_blank" rel="noopener">webfrogs</a></td><td><a href="http://blog.nswebfrog.com/feed/" target="_blank" rel="noopener">http://blog.nswebfrog.com/feed/</a></td></tr><tr><td><a href="http://joeyio.com" target="_blank" rel="noopener">代码手工艺人</a></td><td><a href="http://joeyio.com/atom.xml" target="_blank" rel="noopener">http://joeyio.com/atom.xml</a></td></tr><tr><td><a href="http://gracelancy.com" target="_blank" rel="noopener">Lancy’s Blog</a></td><td><a href="http://gracelancy.com/atom.xml" target="_blank" rel="noopener">http://gracelancy.com/atom.xml</a></td></tr><tr><td><a href="http://www.imallen.com" target="_blank" rel="noopener">I’m Allen</a></td><td><a href="http://www.imallen.com/atom.xml" target="_blank" rel="noopener">http://www.imallen.com/atom.xml</a></td></tr><tr><td><a href="http://imi.im/" target="_blank" rel="noopener">Travis’ Blog</a></td><td><a href="http://imi.im/feed" target="_blank" rel="noopener">http://imi.im/feed</a></td></tr><tr><td><a href="http://wangzz.github.io/" target="_blank" rel="noopener">王中周的技术博客</a></td><td><a href="http://wangzz.github.io/atom.xml" target="_blank" rel="noopener">http://wangzz.github.io/atom.xml</a></td></tr><tr><td><a href="http://wangkewei.cnblogs.com/" target="_blank" rel="noopener">克伟的博客</a></td><td><a href="http://feed.cnblogs.com/blog/u/23857/rss" target="_blank" rel="noopener">http://feed.cnblogs.com/blog/u/23857/rss</a></td></tr><tr><td><a href="http://cnblogs.com/biosli" target="_blank" rel="noopener">摇滚诗人</a></td><td><a href="http://feed.cnblogs.com/blog/u/35410/rss" target="_blank" rel="noopener">http://feed.cnblogs.com/blog/u/35410/rss</a></td></tr><tr><td><a href="http://geeklu.com/" target="_blank" rel="noopener">Luke’s Homepage</a></td><td><a href="http://geeklu.com/feed/" target="_blank" rel="noopener">http://geeklu.com/feed/</a></td></tr><tr><td><a href="http://iiiyu.com/" target="_blank" rel="noopener">萧宸宇</a></td><td><a href="http://iiiyu.com/atom.xml" target="_blank" rel="noopener">http://iiiyu.com/atom.xml</a></td></tr><tr><td><a href="http://www.heyuan110.com/" target="_blank" rel="noopener">Yuan博客</a></td><td><a href="http://www.heyuan110.com/?feed=rss2" target="_blank" rel="noopener">http://www.heyuan110.com/?feed=rss2</a></td></tr><tr><td><a href="http://koofrank.com/" target="_blank" rel="noopener">KooFrank’s Blog</a></td><td><a href="http://koofrank.com/rss" target="_blank" rel="noopener">http://koofrank.com/rss</a></td></tr><tr><td><a href="http://helloitworks.com" target="_blank" rel="noopener">hello it works</a></td><td><a href="http://helloitworks.com/feed" target="_blank" rel="noopener">http://helloitworks.com/feed</a></td></tr><tr><td><a href="http://msching.github.io/" target="_blank" rel="noopener">码农人生</a></td><td><a href="http://msching.github.io/atom.xml" target="_blank" rel="noopener">http://msching.github.io/atom.xml</a></td></tr><tr><td><a href="http://yulingtianxia.com" target="_blank" rel="noopener">玉令天下的Blog</a></td><td><a href="http://yulingtianxia.com/atom.xml" target="_blank" rel="noopener">http://yulingtianxia.com/atom.xml</a></td></tr><tr><td><a href="http://www.hotobear.com/" target="_blank" rel="noopener">不掏蜂窝的熊</a></td><td><a href="http://www.hotobear.com/?feed=rss2" target="_blank" rel="noopener">http://www.hotobear.com/?feed=rss2</a></td></tr><tr><td><a href="https://andelf.github.io/" target="_blank" rel="noopener">猫·仁波切</a></td><td><a href="https://andelf.github.io/atom.xml" target="_blank" rel="noopener">https://andelf.github.io/atom.xml</a></td></tr><tr><td><a href="http://ivoryxiong.org/" target="_blank" rel="noopener">煲仔饭</a></td><td><a href="http://ivoryxiong.org/feed.xml" target="_blank" rel="noopener">http://ivoryxiong.org/feed.xml</a></td></tr><tr><td><a href="http://adad184.com" target="_blank" rel="noopener">里脊串的开发随笔</a></td><td><a href="http://adad184.com/atom.xml" target="_blank" rel="noopener">http://adad184.com/atom.xml</a></td></tr><tr><td><a href="http://blog.callmewhy.com/" target="_blank" rel="noopener">Why’s blog - 汪海的实验室</a></td><td><a href="http://blog.callmewhy.com/atom.xml" target="_blank" rel="noopener">http://blog.callmewhy.com/atom.xml</a></td></tr><tr><td><a href="http://tutuge.me/" target="_blank" rel="noopener">土土哥的技术Blog</a></td><td><a href="http://tutuge.me/atom.xml" target="_blank" rel="noopener">http://tutuge.me/atom.xml</a></td></tr><tr><td><a href="http://www.olinone.com/" target="_blank" rel="noopener">庞海礁的个人空间 </a></td><td><a href="http://www.olinone.com/?feed=rss2" target="_blank" rel="noopener">http://www.olinone.com/?feed=rss2</a></td></tr><tr><td><a href="http://casatwy.com/" target="_blank" rel="noopener">Casa Taloyum</a></td><td><a href="http://casatwy.com/feeds/all.atom.xml" target="_blank" rel="noopener">http://casatwy.com/feeds/all.atom.xml</a></td></tr><tr><td><a href="http://www.cnblogs.com/kenshincui/" target="_blank" rel="noopener">Kenshin Cui’s Blog</a></td><td><a href="http://www.cnblogs.com/kenshincui/rss" target="_blank" rel="noopener">http://www.cnblogs.com/kenshincui/rss</a></td></tr><tr><td><a href="http://suenblog.duapp.com/" target="_blank" rel="noopener">技术哥的博客</a></td><td><a href="http://suenblog.duapp.com/rss/" target="_blank" rel="noopener">http://suenblog.duapp.com/rss/</a></td></tr><tr><td><a href="http://www.tanhao.me/" target="_blank" rel="noopener">老谭笔记</a></td><td><a href="http://www.tanhao.me/atom.xml" target="_blank" rel="noopener">http://www.tanhao.me/atom.xml</a></td></tr><tr><td><a href="http://www.coderyi.com/" target="_blank" rel="noopener">coderyi</a></td><td><a href="http://www.coderyi.com/feed" target="_blank" rel="noopener">http://www.coderyi.com/feed</a></td></tr><tr><td><a href="http://blog.leichunfeng.com" target="_blank" rel="noopener">雷纯锋的技术博客</a></td><td><a href="http://blog.leichunfeng.com/atom.xml" target="_blank" rel="noopener">http://blog.leichunfeng.com/atom.xml</a></td></tr><tr><td><a href="http://www.iosxxx.com/" target="_blank" rel="noopener">向晨宇的技术博客</a></td><td><a href="http://iosxxx.com/atom.xml" target="_blank" rel="noopener">http://iosxxx.com/atom.xml</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转自唐巧的 GitHub: &lt;a href=&quot;https://github.com/tangqiaoboy/iOSBlogCN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文 iOS/Mac 开发博客列表&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本博客列表涉及的文章内容支持 &lt;a href=&quot;https://www.google.com/cse/publicurl?cx=006531766708784105585:e42hjzmqfcu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;定制化Google搜索&lt;/a&gt;，特别感谢 &lt;a href=&quot;https://github.com/JeOam&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JeOam&lt;/a&gt; 提供并帮助更新。&lt;/p&gt;
&lt;p&gt;本博客列表也提供同步更新的OPML文件（&lt;a href=&quot;https://github.com/tangqiaoboy/iOSBlogCN/raw/master/blogcn.opml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载OPML文件&lt;/a&gt;），可供导入到例如feedly/Reeder等第三方定阅工具中，特别感谢 &lt;a href=&quot;https://github.com/icepy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;icepy&lt;/a&gt; 提供自动转换脚本。这里有&lt;a href=&quot;http://blog.feedly.com/feedlimport/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;导入教程&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Blog" scheme="http://oneofai.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>在 iTerm2 中使用⌥→和⌥←来跳转单词</title>
    <link href="http://oneofai.com/2015/11/12/2015-11-12-%E5%9C%A8%20iTerm2%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E2%8C%A5%E2%86%92%E5%92%8C%E2%8C%A5%E2%86%90%E6%9D%A5%E8%B7%B3%E8%BD%AC%E5%8D%95%E8%AF%8D/"/>
    <id>http://oneofai.com/2015/11/12/2015-11-12-在 iTerm2 中使用⌥→和⌥←来跳转单词/</id>
    <published>2015-11-12T15:06:08.000Z</published>
    <updated>2018-01-15T16:13:13.544Z</updated>
    
    <content type="html"><![CDATA[<p>iTerm 2 的默认设置, 在单词间跳转是很痛苦的</p><p>你可以自己通过配置 <code>⌥←</code> and <code>⌥→</code> 快捷键来做到单词间跳转这个动作</p><a id="more"></a> <p>首先需要设置 Left option(⌥) 键为 <code>+Esc</code> 模式</p><p>当然, Right option(⌥) 也是可以的, 只是看你习惯用哪个键</p><p><img src="http://ww2.sinaimg.cn/large/006tNbRwly1ff7hirts2sj31kw0xsdnn.jpg" alt=""></p><p>然后你需要定位到 <code>⌥←</code> 快捷键上, 或者创建一个新的也可以</p><p>然后按照如下设置:</p><p>Keyboard Shortcut: <code>⌥←</code><br>Action: <code>Send Escape Sequence</code><br>Esc+ <code>b</code>    </p><p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ff7hyhcyvfj31kw0xsjyl.jpg" alt=""></p><p>再次重复上边的动作设置 <code>⌥→</code>:</p><p>Keyboard Shortcut: <code>⌥→</code><br>Action: <code>Send Escape Sequence</code><br>Esc+ <code>f</code>   </p><p>好了, 现在通过按住 <code>⌥</code> 键然后点击 <code>←</code> 或者 <code>→</code> 就可以在单词跳转了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iTerm 2 的默认设置, 在单词间跳转是很痛苦的&lt;/p&gt;
&lt;p&gt;你可以自己通过配置 &lt;code&gt;⌥←&lt;/code&gt; and &lt;code&gt;⌥→&lt;/code&gt; 快捷键来做到单词间跳转这个动作&lt;/p&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://oneofai.com/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://oneofai.com/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>iOS 跳转系统设置页面</title>
    <link href="http://oneofai.com/2015/11/06/2015-11-06-ios-%E8%B7%B3%E8%BD%AC%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2/"/>
    <id>http://oneofai.com/2015/11/06/2015-11-06-ios-跳转系统设置页面/</id>
    <published>2015-11-06T04:24:20.000Z</published>
    <updated>2018-01-15T16:13:05.105Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们写业务的时候会有跳转到系统设置界面的需求, 比如当应用未联网的状态下, 可能需要提醒用户去连接网络, 如果只是单单一个提醒, 用户体验可能不是太好, 如果在提醒下边附加上一个跳转到Wi-Fi/蜂窝网络的界面, 是不是就好很多呢? 再比如, 你的 app 是智能家居方面的, 这时候需要 Wi-Fi 或者 Bluetooth 去连接智能家居设备, 那么在打开 app 的时候如果用户没连接 Wi-Fi 或 Bluetooth, 就需要提示用户去设置页面连接</p><a id="more"></a> <p>还有, 有时候, 你的 app 需要获取用户的地理位置, 以此来获取周围的一些信息, 来让 app 体验更好, 或者说根据周围的地理情况来实现某种特性, 那么就需要 app 的定位服务是开启的, 但用户有时候没有开启定位或者把 app 的定位服务关掉了, 用户点击这个功能的时候, app 可能需要作出一个提醒并附带上跳转定位服务的按钮, 当然还有其它像通知、获取联系人、访问日历等等啦, 这个需求是很有必要的</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-info-plist"><a href="#1-info-plist" class="headerlink" title="1. info.plist"></a>1. info.plist</h4><p>在项目中的 info.plist 中添加URL types选项, 并在其下添加一项URL Schemes字段, 值例如为 prefs, 如下</p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1fecwfbw2ymj30x804ejs4.jpg" alt=""></p><p>或者是在这里</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fecwvelfo9j313g0lc0v8.jpg" alt=""></p><h4 id="2-1-OC代码中"><a href="#2-1-OC代码中" class="headerlink" title="2.1. OC代码中"></a>2.1. OC代码中</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳转关于本机</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=General&amp;path=About"</span>];</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Swift"><a href="#2-2-Swift" class="headerlink" title="2.2. Swift"></a>2.2. Swift</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳转键盘页面</span></span><br><span class="line"><span class="type">UIApplication</span>.sharedApplication().openURL(<span class="type">NSURL</span>(string:<span class="string">"prefs:root=General&amp;path=Keyboard"</span>)!)</span><br></pre></td></tr></table></figure><h4 id="3-网上找了一些可以跳转的列表"><a href="#3-网上找了一些可以跳转的列表" class="headerlink" title="3. 网上找了一些可以跳转的列表"></a>3. 网上找了一些可以跳转的列表</h4><table><thead><tr><th>层级</th><th>Schemes</th></tr></thead><tbody><tr><td>The <strong>topmost level</strong> General</td><td><code>prefs:</code></td></tr><tr><td>About</td><td><code>prefs:root=General&amp;path=About</code></td></tr><tr><td>Accessibility</td><td><code>prefs:root=General&amp;path=ACCESSIBILITY</code></td></tr><tr><td>Account Settings</td><td><code>prefs:root=ACCOUNT_SETTINGS</code></td></tr><tr><td>Airplane Mode</td><td><code>prefs:root=AIRPLANE_MODE</code></td></tr><tr><td>Autolock</td><td><code>prefs:root=General&amp;path=AUTOLOCK</code></td></tr><tr><td>Batery</td><td><code>prefs:root=BATTERY_USAGE</code></td></tr><tr><td>Brightness</td><td><code>prefs:root=Brightness</code></td></tr><tr><td>Bluetooth iOS &lt; 9</td><td><code>prefs:root=General&amp;path=Bluetooth</code></td></tr><tr><td>Bluetooth iOS &gt; 9</td><td><code>prefs:root=Bluetooth</code></td></tr><tr><td>Castle</td><td><code>prefs:root=CASTLE</code></td></tr><tr><td>Cellular Usage</td><td><code>prefs:root=General&amp;path=USAGE/CELLULAR_USAGE</code></td></tr><tr><td>Configuration List</td><td><code>prefs:root=General&amp;path=ManagedConfigurationList</code></td></tr><tr><td>Date and Time</td><td><code>prefs:root=General&amp;path=DATE_AND_TIME</code></td></tr><tr><td>Do not disturb</td><td><code>prefs:root=General&amp;path=DO_NOT_DISTURB</code></td></tr><tr><td>Facetime</td><td><code>prefs:root=FACETIME</code></td></tr><tr><td>General</td><td><code>prefs:root=General</code></td></tr><tr><td>Internet Tethering</td><td><code>prefs:root=INTERNET_TETHERING</code></td></tr><tr><td>iTunes</td><td><code>prefs:root=MUSIC</code></td></tr><tr><td>iTunes Equalizer</td><td><code>prefs:root=MUSIC&amp;path=EQ</code></td></tr><tr><td>iTunes Volume</td><td><code>prefs:root=MUSIC&amp;path=VolumeLimit</code></td></tr><tr><td>Keyboard</td><td><code>prefs:root=General&amp;path=Keyboard</code></td></tr><tr><td>Deeper in Keyboard</td><td><code>prefs:root=General&amp;path=Keyboard/KEYBOARDS</code></td></tr><tr><td>Lang International</td><td><code>prefs:root=General&amp;path=INTERNATIONAL</code></td></tr><tr><td>Location Services</td><td><code>prefs:root=LOCATION_SERVICES</code></td></tr><tr><td>Network</td><td><code>prefs:root=General&amp;path=Network</code></td></tr><tr><td>Nike iPod</td><td><code>prefs:root=NIKE_PLUS_IPOD</code></td></tr><tr><td>Notes</td><td><code>prefs:root=NOTES</code></td></tr><tr><td>Notifications ID</td><td><code>prefs:root=NOTIFICATIONS_ID</code></td></tr><tr><td>Passbook</td><td><code>prefs:root=PASSBOOK</code></td></tr><tr><td>Phone</td><td><code>prefs:root=Phone</code></td></tr><tr><td>Photo Camera Roll</td><td><code>prefs:root=Photos</code></td></tr><tr><td>Reset</td><td><code>prefs:root=General&amp;path=Reset</code></td></tr><tr><td>Ringtone</td><td><code>prefs:root=Sounds&amp;path=Ringtone</code></td></tr><tr><td>Siri</td><td><code>prefs:root=SIRI</code></td></tr><tr><td>Safari</td><td><code>prefs:root=Safari</code></td></tr><tr><td>Siri</td><td><code>prefs:root=General&amp;path=Assistant</code></td></tr><tr><td>Sounds</td><td><code>prefs:root=Sounds</code></td></tr><tr><td>Software Update</td><td><code>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</code></td></tr><tr><td>Storage &amp; Backup</td><td><code>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</code></td></tr><tr><td>Store</td><td><code>prefs:root=STORE</code></td></tr><tr><td>Twitter</td><td><code>prefs:root=TWITTER</code></td></tr><tr><td>Usage</td><td><code>prefs:root=General&amp;path=USAGE</code></td></tr><tr><td>Video</td><td><code>prefs:root=VIDEO</code></td></tr><tr><td>VPN</td><td><code>prefs:root=General&amp;path=Network/VPN</code></td></tr><tr><td>Wallpaper</td><td><code>prefs:root=Wallpaper</code></td></tr><tr><td>WIFI</td><td><code>prefs:root=WIFI</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们写业务的时候会有跳转到系统设置界面的需求, 比如当应用未联网的状态下, 可能需要提醒用户去连接网络, 如果只是单单一个提醒, 用户体验可能不是太好, 如果在提醒下边附加上一个跳转到Wi-Fi/蜂窝网络的界面, 是不是就好很多呢? 再比如, 你的 app 是智能家居方面的, 这时候需要 Wi-Fi 或者 Bluetooth 去连接智能家居设备, 那么在打开 app 的时候如果用户没连接 Wi-Fi 或 Bluetooth, 就需要提示用户去设置页面连接&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView 设置字体大小、颜色、背景色</title>
    <link href="http://oneofai.com/2015/10/26/2015-10-26-uiwebview-%E8%AE%BE%E7%BD%AE%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E3%80%81%E9%A2%9C%E8%89%B2%E3%80%81%E8%83%8C%E6%99%AF%E8%89%B2/"/>
    <id>http://oneofai.com/2015/10/26/2015-10-26-uiwebview-设置字体大小、颜色、背景色/</id>
    <published>2015-10-26T11:39:38.000Z</published>
    <updated>2018-01-15T16:12:34.622Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字体大小</span></span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '200%'"</span>];</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.getElementsByTagName('body')[0].style.webkitTextFillColor= 'green'"</span>];</span><br><span class="line">    <span class="comment">//页面背景色</span></span><br><span class="line">    [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.getElementsByTagName('body')[0].style.background='#ffffff'"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Socket 通信原理</title>
    <link href="http://oneofai.com/2015/07/23/2015-07-23-socket-communication-principle/"/>
    <id>http://oneofai.com/2015/07/23/2015-07-23-socket-communication-principle/</id>
    <published>2015-07-23T12:15:23.000Z</published>
    <updated>2018-01-15T16:12:25.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li><a href="#1">网络中进程之间如何通信?</a></li><li><a href="#2">什么是Socket?</a></li><li><a href="#3">socket的基本操作</a><br> 3.1. <a href="#31">socket()函数</a><br> 3.2. <a href="#32">bind()函数</a><br> 3.3. <a href="#33">listen()、connect()函数</a><br> 3.4. <a href="#34">accept()函数</a><br> 3.5. <a href="#35">read()、write()函数等</a><br> 3.6. <a href="#36">close()函数</a>   </li><li><a href="#4">socket中TCP的三次握手建立连接详解</a></li><li><a href="#5">socket中TCP的四次握手释放连接详解</a></li></ol><a id="more"></a> <h2 id="1-网络中进程之间如何通信"><a href="#1-网络中进程之间如何通信" class="headerlink" title="1. 网络中进程之间如何通信?"></a><span id="1">1. 网络中进程之间如何通信?</span></h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><pre><code>1. 消息传递（管道、FIFO、消息队列）2. 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）3. 共享内存（匿名的和具名的）4. 远程过程调用（Solaris门和Sun RPC）</code></pre><p>网络层的”ip地址”可以唯一标识网络中的主机,而传输层的“协议+端口”可以唯一标识主机中的应用程序(进程). 这样利用三元组(ip地址,协议,端口)就可以标识网络的进程了,网络中的进程通信就可以利用这个标志与其它进程进行交互</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字(socket)和UNIX System V的TLI(已经被淘汰),来实现网络进程之间的通信. 就目前而言, 几乎所有的应用程序都是采用socket</p><h2 id="2-什么是Socket"><a href="#2-什么是Socket" class="headerlink" title="2.什么是Socket?"></a><span id="2">2.什么是Socket?</span></h2><p>socket起源于Unix, 而Unix/Linux基本哲学之一就是”一切皆文件”, 都可以用”打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作. 我的理解就是: Socket就是该模式的一个实现, socket即是一种特殊的文件, 一些socket函数就是对其进行的操作(读/写IO、打开、关闭), 后文介绍</p><p>socket一词的起源</p><blockquote><p>在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的, 撰写者为Stephen Carr、Steve Crocker和Vint Cerf. 根据美国计算机历史博物馆的记载, Croker写道：”命名空间的元素都可称为套接字接口. 一个套接字接口构成一个连接的一端, 而一个连接可完全由一对套接字接口规定.” 计算机历史博物馆补充道: “这比BSD的套接字接口定义早了大约12年.”</p></blockquote><h2 id="3-socket的基本操作"><a href="#3-socket的基本操作" class="headerlink" title="3.socket的基本操作"></a><span id="3">3.socket的基本操作</span></h2><p>既然socket是”open—write/read—close”模式的一种实现, 那么socket就提供了这些操作对应的函数接口. 下面以TCP为例, 介绍几个基本的socket接口函数</p><h3 id="3-1-socket-函数"><a href="#3-1-socket-函数" class="headerlink" title="3.1 socket()函数"></a><span id="31">3.1 socket()函数</span></h3><p><code>int socket(int domain, int type, int protocol);</code><br>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符(socket descriptor), 它唯一标识一个socket. 这个socket描述字跟文件描述字一样, 后续的操作都有用到它, 把它作为参数, 通过它来进行一些读写操作</p><p>正如可以给fopen的传入不同参数值, 以打开不同的文件. 创建socket的时候, 也可以指定不同的参数创建不同的socket描述符, socket函数的三个参数分别为：</p><p><code>domain</code>：<br>即协议域, 又称为协议族(family), 常用的协议族有, AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等. 协议族决定了socket的地址类型, 在通信中必须采用对应的地址, 如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址.</p><p><code>type</code>：<br>指定socket类型. 常用的socket类型有, SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等(socket的类型有哪些?)</p><p><code>protocol</code>：<br>故名思意, 就是指定协议. 常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等, 它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议(这里不展开)</p><p>注意：并不是上面的type和protocol可以随意组合的, 如SOCK_STREAM不可以跟IPPROTO_UDP组合. 当protocol为0时, 会自动选择type类型对应的默认协议</p><p>当我们调用socket创建一个socket时, 返回的socket描述字它存在于协议族（address family，AF_XXX）空间中, 但没有一个具体的地址. 如果想要给它赋值一个地址, 就必须调用bind()函数, 否则就当调用connect()、listen()时系统会自动随机分配一个端口</p><h3 id="3-2-bind-函数"><a href="#3-2-bind-函数" class="headerlink" title="3.2 bind()函数"></a><span id="32">3.2 bind()函数</span></h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket. 例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket</p><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>   </p><p>函数的三个参数分别为：</p><p><code>sockfd</code>：<br>即socket描述字, 它是通过socket()函数创建了, 唯一标识一个socket. bind()函数就是将给这个描述字绑定一个名字</p><p><code>addr</code>：<br>一个const struct sockaddr *指针, 指向要绑定给sockfd的协议地址. 这个地址结构根据地址创建socket时的地址协议族的不同而不同, 如ipv4对应的是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv6对应的是：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unix域对应的是：</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="keyword">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>addrlen</code>：<br>对应的是地址的长度.<br>通常服务器在启动的时候都会绑定一个众所周知的地址(如ip地址+端口号), 用于提供服务, 客户就可以通过它来接连服务器; 而客户端就不用指定, 有系统自动分配一个端口号和自身的ip地址组合. 这就是为什么通常服务器端在listen之前会调用bind(), 而客户端就不会调用, 而是在connect()时由系统随机生成一个网络字节序与主机字节序</p><p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型, 这些字节序是指整数在内存中保存的顺序, 这个叫做主机序. 引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端, 高位字节排放在内存的高地址端</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端, 低位字节排放在内存的高地址端</p><p>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit, 其次8～15bit, 然后16～23bit, 最后是24~31bit. 这种传输次序称作大端字节序. 由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序, 因此它又称作网络字节序. 字节序, 顾名思义字节的顺序, 就是大于一个字节类型的数据在内存中的存放顺序, 一个字节的数据没有顺序的问题了</p><p>所以：在将一个地址绑定到socket的时候, 请先将主机字节序转换成为网络字节序, 而不要假定主机字节序跟网络字节序一样使用的是Big-Endian. 由于这个问题曾引发过血案! 公司项目代码中由于存在这个问题, 导致了很多莫名其妙的问题, 所以请谨记对主机字节序不要做任何假定, 务必将其转化为网络字节序再赋给socket</p><h3 id="3-3-listen-、connect-函数"><a href="#3-3-listen-、connect-函数" class="headerlink" title="3.3 listen()、connect()函数"></a><span id="33">3.3 listen()、connect()函数</span></h3><p>如果作为一个服务器, 在调用socket()、bind()之后就会调用listen()来监听这个socket, 如果客户端这时调用connect()发出连接请求, 服务器端就会接收到这个请求</p><p><code>int listen(int sockfd, int backlog);</code><br><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>listen函数的第一个参数即为要监听的socket描述字, 第二个参数为相应socket可以排队的最大连接个数. socket()函数创建的socket默认是一个主动类型的, listen函数将socket变为被动类型的, 等待客户的连接请求</p><p>connect函数的第一个参数即为客户端的socket描述字, 第二参数为服务器的socket地址, 第三个参数为socket地址的长度. 客户端通过调用connect函数来建立与TCP服务器的连接</p><h3 id="3-4-accept-函数"><a href="#3-4-accept-函数" class="headerlink" title="3.4 accept()函数"></a><span id="34">3.4 accept()函数</span></h3><p>TCP服务器端依次调用socket()、bind()、listen()之后, 就会监听指定的socket地址了. TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求. TCP服务器监听到这个请求之后, 就会调用accept()函数取接收请求, 这样连接就建立好了. 之后就可以开始网络I/O操作了, 即类同于普通文件的读写I/O操作</p><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>accept函数的第一个参数为服务器的socket描述字, 第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址, 第三个参数为协议地址的长度. 如果accpet成功, 那么其返回值是由内核自动生成的一个全新的描述字, 代表与返回客户的TCP连接</p><p>注意：accept的第一个参数为服务器的socket描述字, 是服务器开始调用socket()函数生成的, 称为监听socket描述字; 而accept函数返回的是已连接的socket描述字. 一个服务器通常通常仅仅只创建一个监听socket描述字, 它在该服务器的生命周期内一直存在. 内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字, 当服务器完成了对某个客户的服务, 相应的已连接socket描述字就被关闭</p><h3 id="3-5-read-、write-等函数"><a href="#3-5-read-、write-等函数" class="headerlink" title="3.5 read()、write()等函数"></a><span id="35">3.5 read()、write()等函数</span></h3><p>万事具备只欠东风, 至此服务器与客户已经建立好连接了. 可以调用网络I/O进行读写操作了, 即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure><p>我推荐使用recvmsg()/sendmsg()函数, 这两个函数是最通用的I/O函数, 实际上可以把上面的其它函数都替换成这两个函数. 它们的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">            <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">              struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags);</span><br><span class="line">```       </span><br><span class="line">read函数是负责从fd中读取内容.当读成功时, read返回实际所读的字节数, 如果返回的值是<span class="number">0</span>表示已经读到文件的结束了, 小于<span class="number">0</span>表示出现了错误. 如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题</span><br><span class="line"></span><br><span class="line">write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数. 失败时返回<span class="number">-1</span>, 并设置errno变量. 在网络程序中, 当我们向套接字文件描述符写时有俩种可能.</span><br><span class="line"><span class="number">1</span>)write的返回值大于<span class="number">0</span>, 表示写了部分或者是全部的数据</span><br><span class="line"><span class="number">2</span>)返回的值小于<span class="number">0</span>, 此时出现了错误.我们要根据错误类型来处理. 如果错误为EINTR表示在写的时候出现了中断错误. 如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)</span><br><span class="line"></span><br><span class="line">其它的我就不一一介绍这几对I/O函数了, 具体参见man文档或者baidu、Google, 下面的例子中将使用到send/recv</span><br><span class="line"></span><br><span class="line">### &lt;span id = <span class="string">"36"</span>&gt;<span class="number">3.6</span> close()函数&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">在服务器与客户端建立连接之后, 会进行一些读写操作, 完成了读写操作就要关闭相应的socket描述字, 好比操作完打开的文件要调用fclose关闭打开的文件</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"><span class="keyword">int</span> close(<span class="keyword">int</span> fd);</span><br></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭, 然后立即返回到调用进程. 该描述字不能再由调用进程使用, 也就是说不能再作为read或write的第一个参数</p><p>注意：close操作只是使相应socket描述字的引用计数-1, 只有当引用计数为0的时候, 才会触发TCP客户端向服务器发送终止连接请求</p><h2 id="4-socket中TCP的三次握手建立连接详解"><a href="#4-socket中TCP的三次握手建立连接详解" class="headerlink" title="4. socket中TCP的三次握手建立连接详解"></a><span id="4">4. socket中TCP的三次握手建立连接详解</span></h2><p>我们知道tcp建立连接要进行“三次握手”, 即交换三个分组. 大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K, 并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手, 但是这个三次握手发生在socket的那几个函数中呢?</p><p>请看下图:<br><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fe7xi8nw9rj30ib0c5q3o.jpg" alt="TCP_three_times_handshake"></p><p>从图中可以看出, 当客户端调用connect时, 触发了连接请求, 向服务器发送了SYN J包, 这时connect进入阻塞状态; 服务器监听到连接请求, 即收到SYN J包, 调用accept函数接收请求向客户端发送SYN K , ACK J+1, 这时accept进入阻塞状态; 客户端收到服务器的SYN K , ACK J+1之后, 这时connect返回，并对SYN K进行确认; 服务器收到ACK K+1时, accept返回, 至此三次握手完毕, 连接建立</p><p><strong>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回</strong></p><h2 id="5-socket中TCP的四次握手释放连接详解"><a href="#5-socket中TCP的四次握手释放连接详解" class="headerlink" title="5. socket中TCP的四次握手释放连接详解"></a><span id="5">5. socket中TCP的四次握手释放连接详解</span></h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数. 现在我们介绍socket中的四次握手释放连接的过程, 请看下图：<br><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fe7xisqncoj30ib0c5mxs.jpg" alt="TCP_four_times_handshake"></p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接, 这时TCP发送一个FIN M;</li><li>另一端接收到FIN M之后, 执行被动关闭, 对这个FIN进行确认. 它的接收也作为文件结束符传递给应用进程, 因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据;</li><li>一段时间之后, 接收到文件结束符的应用进程调用close关闭它的socket. 这导致它的TCP也发送一个FIN N;</li><li>接收到这个FIN的源发送端TCP对它进行确认</li></ul><p>这样每个方向上都有一个FIN和ACK</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Contents&quot;&gt;&lt;a href=&quot;#Contents&quot; class=&quot;headerlink&quot; title=&quot;Contents&quot;&gt;&lt;/a&gt;Contents&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;网络中进程之间如何通信?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;什么是Socket?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;socket的基本操作&lt;/a&gt;&lt;br&gt; 3.1. &lt;a href=&quot;#31&quot;&gt;socket()函数&lt;/a&gt;&lt;br&gt; 3.2. &lt;a href=&quot;#32&quot;&gt;bind()函数&lt;/a&gt;&lt;br&gt; 3.3. &lt;a href=&quot;#33&quot;&gt;listen()、connect()函数&lt;/a&gt;&lt;br&gt; 3.4. &lt;a href=&quot;#34&quot;&gt;accept()函数&lt;/a&gt;&lt;br&gt; 3.5. &lt;a href=&quot;#35&quot;&gt;read()、write()函数等&lt;/a&gt;&lt;br&gt; 3.6. &lt;a href=&quot;#36&quot;&gt;close()函数&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;socket中TCP的三次握手建立连接详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;socket中TCP的四次握手释放连接详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="通信" scheme="http://oneofai.com/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="http://oneofai.com/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="Socket" scheme="http://oneofai.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Git 设置代理</title>
    <link href="http://oneofai.com/2015/07/16/2015-07-16-Git-%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://oneofai.com/2015/07/16/2015-07-16-Git-设置代理/</id>
    <published>2015-07-16T13:20:50.000Z</published>
    <updated>2018-01-15T16:12:12.204Z</updated>
    
    <content type="html"><![CDATA[<p>有时候<del>网络状态不是那么好的时候</del>, 相信你们都遇到过, 但作为一个程序员, 我觉得应该具备随时访问 <code>Google</code>、<code>Twitter</code>等网站的能力</p><a id="more"></a> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:9091'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:9091'</span></span><br><span class="line"><span class="comment">#ss 默认是1080</span></span><br></pre></td></tr></table></figure><p>尽情畅游</p><h3 id="另外-curl"><a href="#另外-curl" class="headerlink" title="另外 curl"></a>另外 curl</h3><p>一个道理</p><p>在<code>~/.zshrc</code> 中对 <code>curl</code> 设置 <code>alias</code>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> curl=<span class="string">"curl -x socks5://127.0.0.1:9091"</span></span><br></pre></td></tr></table></figure><p>如果你使用的是<code>bash</code>, 那就设置<code>~/.bashrc</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候&lt;del&gt;网络状态不是那么好的时候&lt;/del&gt;, 相信你们都遇到过, 但作为一个程序员, 我觉得应该具备随时访问 &lt;code&gt;Google&lt;/code&gt;、&lt;code&gt;Twitter&lt;/code&gt;等网站的能力&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://oneofai.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://oneofai.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>UITableView 上下滑动控制底部按钮的出现和消失</title>
    <link href="http://oneofai.com/2015/05/15/2015-05-15-uitableview-%E4%B8%8A%E4%B8%8B%E6%BB%91%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%BA%95%E9%83%A8%E6%8C%89%E9%92%AE%E7%9A%84%E5%87%BA%E7%8E%B0%E5%92%8C%E6%B6%88%E5%A4%B1/"/>
    <id>http://oneofai.com/2015/05/15/2015-05-15-uitableview-上下滑动控制底部按钮的出现和消失/</id>
    <published>2015-05-15T13:32:43.000Z</published>
    <updated>2018-01-15T16:12:05.670Z</updated>
    
    <content type="html"><![CDATA[<p>先来看下效果</p><a id="more"></a> <p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fedprmhqg3g30ae0ikhdt.gif" alt=""></p><p>三个点:</p><ul><li>UITableView 向上滑动, 底部按钮消失</li><li>UITableView 向下滑动, 底部按钮出现</li><li>UITablView 滑动到底部, 底部按钮出现</li></ul><p>我们只需要判断 UITableView 是往上滑动, 还是往下滑动, 以及判断 UITableView 是否滑动到底部即可</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li>创建一个底部按钮:</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.bottomButton = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line"><span class="keyword">self</span>.bottomButton.frame = <span class="built_in">CGRectMake</span>(SCREEN.width / <span class="number">2</span> - <span class="number">25</span>, SCREEN.height - <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">[<span class="keyword">self</span>.bottomButton setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bottom"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.bottomButton];</span><br></pre></td></tr></table></figure><p>既然是控制按钮的出现和消失, 首先要创建一个底部按钮, SCREEN是个宏定义:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define SCREEN [UIScreen mainScreen].bounds.size</span></span><br></pre></td></tr></table></figure><ol><li>判断UITablView上下滑动</li></ol><p>我们都知道, UITableView 是继承 UIScrollView 的. 所以 UIScrollView 的代理方法在 UITableView 是可以使用的. 要判断 UITableView 上下滑动, 我们需要实现 UIScrollView 的 <code>scrollViewDidScroll:</code> 代理方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.y &gt; <span class="keyword">self</span>.offsetY &amp;&amp; scrollView.contentOffset.y &gt; <span class="number">0</span>) <span class="comment">//如果当前位移大于缓存位移，说明scrollView向上滑动</span></span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (scrollView.contentOffset.y &lt; <span class="keyword">self</span>.offsetY)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.offsetY = scrollView.contentOffset.y; <span class="comment">//将当前位移变成缓存位移</span></span><br></pre></td></tr></table></figure><ol><li>判断 UITableView 滑动到底部</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断滑动到底部</span></span><br><span class="line"><span class="keyword">if</span> (scrollView.contentOffset.y == scrollView.contentSize.height - <span class="keyword">self</span>.tableView.frame.size.height)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>按钮消失和出现</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮消失</span></span><br><span class="line">[<span class="built_in">UIView</span> transitionWithView:<span class="keyword">self</span>.bottomButton duration:<span class="number">0.5</span> options:<span class="built_in">UIViewAnimationOptionTransitionNone</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.bottomButton.frame = <span class="built_in">CGRectMake</span>(SCREEN.width / <span class="number">2</span> - <span class="number">25</span>, SCREEN.height, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125; completion:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮出现</span></span><br><span class="line">[<span class="built_in">UIView</span> transitionWithView:<span class="keyword">self</span>.bottomButton duration:<span class="number">0.5</span> options:<span class="built_in">UIViewAnimationOptionTransitionNone</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.bottomButton.frame = <span class="built_in">CGRectMake</span>(SCREEN.width / <span class="number">2</span> - <span class="number">25</span>, SCREEN.height - <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125; completion:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure><p>按钮消失其实就是移除屏幕, 这里我加了一个旋转的过度动画, 需要什么动画效果都可以选择. 按钮出现就是把按钮的 <code>frame</code> 设置到初始化时候的 <code>frame</code> 即可</p><p><a href="https://github.com/oneofai/UITableViewControlButton" target="_blank" rel="noopener">Demo 地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来看下效果&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime</title>
    <link href="http://oneofai.com/2015/04/21/2015-04-21-objective-c-runtime/"/>
    <id>http://oneofai.com/2015/04/21/2015-04-21-objective-c-runtime/</id>
    <published>2015-04-21T02:15:29.000Z</published>
    <updated>2018-01-15T16:22:11.962Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自杨萧玉博客: <a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime" target="_blank" rel="noopener">玉令天下</a></p></blockquote><p>本文详细整理了 <strong>Cocoa</strong> 的 <strong>Runtime</strong> 系统的知识, 它使得 <strong>Objective-C</strong> 如虎添翼, 具备了灵活的动态特性, 使这门古老的语言焕发生机</p><a id="more"></a> <p>主要内容如下:</p><hr><ul><li><strong><a href="#introduction">引言</a></strong></li><li><strong><a href="#intro">简介</a></strong></li><li><strong><a href="#interaction_with_runtime">与Runtime交互</a></strong></li><li><strong><a href="#runtime_jargon">Runtime术语</a></strong></li><li><strong><a href="#message">消息</a></strong></li><li><strong><a href="#dynamic_method_parse">动态方法解析</a></strong></li><li><strong><a href="#message_forward">消息转发</a></strong></li><li><strong><a href="#robust_instance">健壮的实例变量(Non Fragile ivars)</a></strong></li><li><strong><a href="#objc_Associated_obj">Objective-C Associated Objects</a></strong></li><li><strong><a href="#method-swizzling">Method Swizzling</a></strong></li><li><strong><a href="#summary">总结</a></strong></li></ul><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><span id="introduction">引言</span></h2><p>曾经觉得Objective-C特别方便上手, 面对着 Cocoa 中大量 API, 只知道简单的查文档和调用. 还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单的方法调用, 而无视了 <strong>“发送消息”</strong> 这句话的深刻含义. 于是<code>[receiver message]</code>会被编译器转化为:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure></p><p>如果消息含有参数, 则为:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p><ul><li>如果消息的接收者能够找到对应的<code>selector</code>, 那么就相当于直接执行了接收者这个对象的特定方法;  否则, 消息要么被转发, 或是临时向接收者动态添加这个<code>selector</code> 对应的实现内容, 要么就干脆玩完崩溃掉</li><li>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用. 因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息, 而<code>receive</code>将要如何响应这条消息, 那就要看运行时发生的情况来决定了</li><li><strong>Objective-C</strong> 的 <strong>Runtime</strong> 铸就了它动态语言的特性, 这些深层次的知识虽然平时写代码用的少一些, 但是却是每个 <strong>Objective-C</strong> 程序员需要了解的   </li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span id="intro">简介</span></h2><p>因为 <strong>Objective-C</strong> 是一门动态语言, 所以它总是想办法把一些决定工作从编译连接推迟到运行时. 也就是说只有编译器是不够的, 还需要一个运行时系统 (<code>runtime system</code>) 来执行编译后的代码. 这就是 <strong>Objective-C Runtime</strong> 系统存在的意义, 它是整个Objc运行框架的一块基石</p><p><strong>Runtime</strong> 其实有两个版本:“modern”和 “legacy”. 我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统, 只能运行在 iOS 和 OS X 10.5 之后的64位程序中. 而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统. <code>这两个版本最大的区别在于当你更改一个类的实例变量的布局时, 在早期版本中你需要重新编译它的子类, 而现行版就不需要</code></p><p>Runtime基本是 <strong>C和汇编</strong> 写的, 可见苹果为了动态系统的高效而作出的努力. 你可以在<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码. 苹果和GNU各自维护一个开源的Runtime版本, 这两个版本之间都在努力的保持一致</p><h2 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a><span id="interaction_with_runtime">与Runtime交互</span></h2><p>Objectie-C 从三种不同的层级上与 Runtime 系统进行交互, 分别是通过 Objective-C 源代码, 通过 <code>Foundation</code> 框架的 <code>NSObject</code> 类定义的方法, 通过对 runtime 函数的直接调用</p><h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行, Runtime 系统自动在幕后辛勤劳作着. 还记得引言中举的例子吧, 消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数, Objective-C中的类、方法和协议等在 Runtime 中都由一些数据结构来定义, 这些内容在后面会讲到. （比如 <code>objc_msgSend</code> 函数及其参数列表中的 <code>id</code> 和 <code>SEL</code> 都是啥）</p><h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa 中大多数类都继承于 NSObject 类, 也就自然继承了它的方法. 最特殊的例外是 NSProxy , 它是个抽象超类, 它实现了一些消息转发有关的方法, 可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类, 说白了就是领导把自己展现给大家风光无限, 但是把活儿都交给幕后小弟去干</p><p>有的 NSObject 中的方法起到了抽象接口的作用, 比如 description 方法需要你重载它并为你定义的类提供描述内容. NSObject 还有些方法能在运行时获得类的信息, 并检查一些特性, 比如 class 返回对象的类; <code>isKindOfClass:</code> 和<code>isMemberOfClass:</code> 则检查对象是否在指定的类继承体系中; <code>respondsToSelector:</code> 检查对象能否响应指定的消息; <code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法; <code>methodForSelector:</code>则返回指定方法实现的地址</p><h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成, 具有公共接口的动态共享库. 头文件存放于<code>/usr/include/objc</code> 目录下. 许多函数允许你用纯C代码来重复实现 Objc 中同样的功能. 虽然有一些方法构成了 NSObject 类的基础, 但是你在写 Objc 代码时一般不会直接用到这些函数的, 除非是写一些 Objc 与其他语言的桥接或是底层的debug工作. 在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档</p><h2 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a><span id="runtime_jargon">Runtime术语</span></h2><p>还记得引言中的 <code>objc_msgSend:</code>方法吧, 它的真身是这样的:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend ( <span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ... );</span><br></pre></td></tr></table></figure></p><p>下面将会逐渐展开介绍一些术语, 其实它们都对应着数据结构</p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code> 函数第二个参数类型为SEL , 它是selector 在Objc中的表示类型（Swift中是Selector类）. selector 是方法选择器, 可以理解为区分方法的 ID, 而这个 ID 的数据结构是SEL:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>其实它就是个映射到方法的C字符串, 你可以用 Objc 编译器命令<code>@selector()</code> 或者 Runtime 系统的  <code>sel_registerName</code>函数来获得一个SEL 类型的方法选择器<br>不同类中相同名字的方法所对应的方法选择器是相同的, 即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器, 于是 Objc 中方法命名有时会带上参数类型( <code>NSNumber</code> 一堆抽象工厂方法拿走不谢), Cocoa 中有好多长长的方法哦</p><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code> 第一个参数类型为id, 大家对它都不陌生, 它是一个指向类实例的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p><p>那 <code>objc_object</code> 又是啥呢:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure></p><p><code>objc_object</code> 结构体包含一个isa指针, 根据isa指针就可以顺藤摸瓜找到对象所属的类</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说isa是指针是因为Class其实是一个指向<code>objc_class</code>结构体的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p><p>而<code>objc_class</code>就是我们摸到的那个瓜, 里面的东西多着呢:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name</span><br><span class="line">    <span class="keyword">long</span> version</span><br><span class="line">    <span class="keyword">long</span> info</span><br><span class="line">    <span class="keyword">long</span> instance_size</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols</span><br><span class="line"><span class="meta">#endif         </span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p><p>可以看到运行时一个类还关联了它的超类指针, 类名, 成员变量, 方法, 缓存, 还有附属的协议.  其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">     <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete</span><br><span class="line">    <span class="keyword">int</span> method_count</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">     <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你C语言不是特别好, 可以直接理解为<code>objc_ivar_list</code>结构体存储<code>objc_ivar</code> 数组列表, 而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息; 同理<code>objc_method_list</code> 结构体存储着<code>objc_method</code>数组列表, 而<code>objc_method</code>结构体存储了类的某个方法的信息</p><p>最后要提到的还有一个<code>objc_cache</code>, 顾名思义它是缓存, 它在<code>objc_class</code>的作用很重要, 在后面会讲到</p><p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象, 这是因为一个 ObjC 类本身同时也是一个对象, 为了处理类和对象的关系, runtime 库创建了一种叫做元类 (Meta Class) 的东西, 类对象所属类型就叫做元类, 它用来表述类对象本身所具备的元数据. 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 当你发出一个类似<code>[NSObject alloc]</code>的消息时, 你事实上是把这个消息发给了一个类对象 (Class Object) , 这个类对象必须是一个元类的实例, 而这个元类同时也是一个根元类 (root meta class) 的实例</p><p>你会说 NSObject 的子类时, 你的类就会指向NSObject 做为其超类. 但是所有的元类最终都指向根元类为其超类. 所有的元类的方法列表都有能够响应消息的类方法. 所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候, <code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法, 如果找到了, 然后对这个类对象执行方法调用</p><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1febgap6hr9j30fa0fzta4.jpg" alt="struct"></p><p>上图实线是 <code>super_class</code> 指针, 虚线是<code>isa</code>指针.  有趣的是根元类的超类是NSObject, 而<code>isa</code>指向了自己, 而NSObject的超类为nil, 也就是它没有超类</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method是一种代表类中的某个方法的类型<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br></pre></td></tr></table></figure></p><p>而<code>objc_method</code>在上面的方法列表中提到过, 它存储了方法名, 方法类型和方法实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name</span><br><span class="line">    <span class="keyword">char</span> *method_types</span><br><span class="line">    IMP method_imp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>方法名类型为<code>SEL</code>, 前面提到过相同名字的方法即使在不同类中定义, 它们的方法选择器也相同</p></li><li><p>方法类型<code>method_types</code>是个char指针, 其实存储着方法的参数类型和返回值类型</p></li><li><code>method_imp</code>指向了方法的实现, 本质上是一个函数指针, 后面会详细讲到</li></ul><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar是一种代表类中实例变量的类型<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br></pre></td></tr></table></figure></p><p>而<code>objc_ivar</code>在上面的成员变量列表中也提到过:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name</span><br><span class="line">    <span class="keyword">char</span> *ivar_type</span><br><span class="line">    <span class="keyword">int</span> ivar_offset</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PS: <code>OBJC2_UNAVAILABLE</code> 之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法, 有兴趣的可以<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">查看源码</a></p><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP在<code>objc.h</code>中的定义是:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br></pre></td></tr></table></figure></p><p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">函数指针</a>, 这是由编译器生成的. 当你发起一个 <code>ObjC</code> 消息之后, 最终它会执行的那段代码, 就是由这个函数指针指定的. 而 IMP 这个函数指针就指向了这个方法的实现. 既然得到了执行某个实例某个方法的入口, 我们就可以绕开消息传递阶段, 直接执行方法, 这在后面会提到</p><p>你会发现IMP指向的方法与<code>objc_msgSend</code>函数类型相同, 参数都包含<code>id</code>和<code>SEL</code>类型. 每个方法名都对应一个<code>SEL</code>类型的方法选择器, 而每个实例对象中 <code>SEL</code>对应的方法实现肯定是唯一的, 通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址; 反之亦然</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在<code>runtime.h</code>中Cache的定义如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br></pre></td></tr></table></figure></p><p>还记得之前<code>objc_class</code>结构体中有一个<code>struct objc_cache *cache</code>吧, 它到底是缓存啥的呢, 先看看<code>objc_cache</code>的实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied</span><br><span class="line">    Method buckets[<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Cache</code>为方法调用的性能进行优化, 通俗地讲, 每当实例对象接收到一个消息时, 它不会直接在<code>isa</code>指向的类的方法列表中遍历查找能够响应消息的方法, 因为这样效率太低了, 而是优先在Cache中查找. Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用, 那么它有可能今后还会被调用）, 下次查找的时候效率更高. 这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像, 而我猜苹果为提高Cache命中率应该也做了努力吧</p><h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p><code>@property</code>标记了类中的属性, 这个不必多说大家都很熟悉, 它是一个指向<code>objc_property</code>结构体的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;<span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure></p><p>可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code>方法来获取类和协议中的属性:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p><p>返回类型为指向指针的指针, 哈哈, 因为属性列表是个数组, 每个元素内容都是一个<code>objc_property_t</code>指针, 而这两个函数返回的值是指向这个数组的指针   </p><p>举个栗子, 先声明一个类:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>你可以用下面的代码获取属性列表:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure></p><p>你可以用<code>property_getName</code>函数来查找属性名称:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</span><br></pre></td></tr></table></figure><p>你可以用<code>class_getProperty</code> 和 <code>protocol_getProperty</code>通过给出的名称来在类和协议中获取属性的引用:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br></pre></td></tr></table></figure></p><p>你可以用<code>property_getAttributes</code>函数来发掘属性的名称和<code>@encode</code>类型字符串:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure></p><p>把上面的代码放一起, 你就能从一个类中获取它的属性啦:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++)&#123;</span><br><span class="line">    objc_property_t property = properties[i];    </span><br><span class="line">    printf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a><span id="message">消息</span></h2><p>前面做了这么多铺垫, 现在终于说到了消息了. Objc 中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来, 而直到运行时才会把消息与方法实现绑定</p><h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在引言中已经对<code>objc_msgSend</code>进行了一点介绍, 看起来像是<code>objc_msgSend</code>返回了数据, 其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据</p><p>下面详细叙述下消息发送步骤:</p><ol><li>检测这个 <code>selector</code> 是不是要忽略的. 比如 Mac OS X 开发, 有了垃圾回收就不理会 retain,release 这些函数了   </li><li>检测这个 target 是不是 nil 对象. ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash, 因为会被忽略掉</li><li>如果上面两个都过了, 那就开始查找这个类的 IMP, 先从 cache 里面找, 完了找得到就跳到对应的函数去执行</li><li>如果 cache 找不到就找一下方法分发表</li><li>如果分发表找不到就到超类的分发表去找, 一直找, 直到找到NSObject 类为止</li><li>如果还找不到就要开始进入<code>动态方法</code>解析了, 后面会提到</li></ol><p>PS:这里说的分发表其实就是<code>Class</code>中的方法列表, 它将方法选择器和方法实现地质联系起来<br><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""><br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或<code>objc_msgSendSuper_stret</code> 四个方法中选择一个来调用. 如果消息是传递给超类, 那么会调用名字带有”Super”的函数; 如果消息返回值是数据结构而不是简单值时, 那么会调用名字带有”stret”的函数. 排列组合正好四个方法</p><p>值得一提的是在 i386 平台处理返回类型为浮点数的消息时, 需要用到<code>objc_msgSend_fpret</code>函数来进行处理, 这是因为返回类型为浮点数的函数对应的 ABI(Application Binary Interface) 与返回整型的函数的 ABI 不兼容. 此时<code>objc_msgSend</code>不再适用, 于是<code>objc_msgSend_fpret</code>被派上用场, 它会对浮点数寄存器做特殊处理. 不过在 PPC 或 PPC64 平台是不需要麻烦它的</p><p>PS: 有木有发现这些函数的命名规律哦? 带“Super”的是消息传递给超类; “stret”可分为“st”+“ret”两部分, 分别代表“struct”和“return”; “fpret”就是“fp”+“ret”, 分别代表“floating-point”和“return”</p><h4 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h4><p>我们经常在方法中使用<code>self</code>关键字来引用实例本身, 但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧. 其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的   </p><p>当<code>objc_msgSend</code>找到方法对应的实现时, 它将直接调用该方法实现, 并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p><ul><li>接收消息的对象（也就是<code>self</code>指向的内容）</li><li>方法选择器（<code>_cmd</code>指向的内容）</li></ul><p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数. 它们是在代码被编译时被插入实现中的. 尽管这些参数没有被明确声明, 在源代码中我们仍然可以引用它们. 在下面的例子中, <code>self</code>引用了接收者对象, 而<code>_cmd</code>引用了方法本身的选择器:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个参数中, <code>self</code> 更有用. 实际上,它是在方法实现中访问消息接收者对象的实例变量的途径<br>而当使用<code>[super XXXX]</code> 调用时, 会使用 <code>objc_msgSendSuper</code> 函数, 看下 objc_msgSendSuper 的函数定义:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p><p>第一个参数是个<code>objc_super</code>的结构体, 第二个参数还是类似上面的类方法的<code>selector</code>, 先看下objc_super这个结构体是什么东西:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">id</span> receiver;</span><br><span class="line">     Class superClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到这个结构体包含了两个成员, 一个是 receiver, 这个类似上面 <code>objc_msgSend</code> 的第一个参数 receiver, 第二个成员是记录写 super 这个类的父类是什么, 拿上面的代码为例, 当编译器遇到 PersonMe 里<code>setName:andAge</code> 方法里的 <code>[super setName:]</code> 时, 开始做这几个事: 构建 <code>objc_super</code> 的结构体, 此时这个结构体的第一个成员变量 <code>receiver</code> 就是 <code>PersonMe *me</code>, 和 <code>self</code> 相同. 而第二个成员变量 <code>superClass</code> 就是指类 <code>Person</code>, 因为 <code>PersonMe</code> 的超类就是这个 Person</p><p>调用 <code>objc_msgSendSuper</code> 的方法, 将这个结构体和 <code>setName</code> 的 <code>sel</code> 传递过去. 函数里面在做的事情类似这样: 从 <code>objc_super</code> 结构体指向的 <code>superClass</code>的方法列表开始找 <code>setName</code> 的 <code>selector</code>, 找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 <code>selector</code>, 可能也会使用 <code>objc_msgSend</code> 这个函数, 不过此时的第一个参数 <code>theReceiver</code> 就是 <code>objc_super-&gt;receiver</code>, 第二个参数是从 <code>objc_super-&gt;superClass</code> 中找到的 <code>selector</code></p><p>例如:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"self ' class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"super' class is %@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure></p><p>而当方法中的<code>super</code>关键字接收到消息时, 编译器会创建一个<code>objc_super</code>结构体:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> receiver;</span><br><span class="line">    Class <span class="keyword">class</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个结构体指明了消息应该被传递给特定超类的定义. 但<code>receiver</code>仍然是<code>self</code>本身, 这点需要注意, 因为当我们想通过<code>[super class]</code> 获取超类时, 编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数, 因为只有在<code>NSObject</code>类找到<code>class</code>方法, 然后<code>class</code>方法调用<code>object_getClass()</code>, 接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>, 传入的第一个参数是指向<code>self</code>的<code>id</code>指针, 与调用<code>[self class]</code>相同, 所以我们得到的永远都是<code>self</code>的类型</p><h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在<code>IMP</code>那节提到过可以避开消息绑定而直接获取方法的地址并调用方法. 这种做法很少用, 除非是需要持续大量重复调用某方法的极端情况, 避开消息发送泛滥而直接调用该方法会更高效.<br><code>NSObject</code>类中有个<code>methodForSelector:</code>实例方法, 你可以用它来获取某个方法选择器对应的IMP, 举个栗子:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))</span><br><span class="line">    [target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><p>当方法被当做函数调用时, 上节提到的两个隐藏参数就需要我们明确给出了. 上面的例子调用了1000次函数, 你可以试试直接给<code>target</code>发送1000次<code>setFilled:</code>消息会花多久<br>PS: <code>methodForSelector:</code>方法是由 Cocoa 的 Runtime 系统提供的, 而不是 Objc 自身的特性</p><h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a><span id="dynamic_method_parse">动态方法解析</span></h2><p>你可以动态地提供一个方法的实现. 例如我们可以用@dynamic    </p><p>关键字在类的实现文件中修饰一个属性:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure></p><p>这表明我们会为这个属性动态提供存取方法, 也就是说编译器不会再默认为我们生成<code>setPropertyName:</code>和<code>propertyName</code>方法, 而需要我们动态提供. 我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现. 因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时, Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会. 我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically))</span><br><span class="line">    &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面的例子为resolveThisMethodDynamically方法添加了实现内容, 也就是dynamicMethodIMP方法中的代码. 其中 “v@: ” 表示返回值和参数, 这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p><p>PS: 动态方法解析会在消息转发机制侵入前执行. 如果 <code>respondsToSelector:</code> 或<code>instancesRespondToSelector:</code> 方法被执行, 动态方法解析器将会被首先给予一个提供该方法选择器对应的 IMP 的机会. 如果你想让该方法选择器被传送到转发机制, 那么就让<code>resolveInstanceMethod:</code> 返回NO</p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a><span id="message_forward">消息转发<span></span></span></h2><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febh76h7jnj30m80h6ab1.jpg" alt=""></p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前, Runtime 系统会再给我们一次偷梁换柱的机会, 即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>毕竟消息转发要耗费更多时间, 抓住这次机会将消息重定向给别人是个不错的选择, 不过千万别返回self, 因为那样会死循环   </p><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回NO 时, 消息转发机制会被触发. 在这时<code>forwardInvocation:</code> 方法会被执行, 我们可以重写这个方法来定义我们的转发逻辑:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector: [anInvocation selector]])     </span><br><span class="line">    &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该消息的唯一参数是个NSInvocation 类型的对象——该对象封装了原始的消息和消息的参数. 我们可以实现<code>forwardInvocation:</code> 方法来对不能处理的消息做一些默认的处理, 也可以将消息转发给其他对象来处理, 而不抛出错误</p><p>这里需要注意的是参数anInvocation 是从哪的来的呢？其实在<code>forwardInvocation:</code> 消息发送前, Runtime系统会向对象发送<code>methodSignatureForSelector:</code> 消息, 并取到返回的方法签名用于生成NSInvocation 对象. 所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code> 方法, 否则会抛异常</p><p>当一个对象由于没有相应的方法实现而无法响应某消息时, 运行时系统将通过<code>forwardInvocation:</code>消息通知该对象. 每个对象都从NSObject类中继承了<code>forwardInvocation:</code>方法. 然而, NSObject中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>. 通过实现我们自己的<code>forwardInvocation:</code>方法, 我们可以在该方法实现中将消息转发给其它对象</p><p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心, 将这些消息转发给不同接收对象. 或者它也可以象一个运输站将所有的消息都发送给同一个接收对象. 它可以将一个消息翻译成另外一个消息, 或者简单的”吃掉“某些消息, 因此没有响应也没有错误. <code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应, 这一切都取决于方法的具体实现. 该方法所提供是将不同的对象链接到消息链的能力</p><p>注意:  </p><blockquote><p><code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用.  所以, 如果我们希望一个对象将negotiate消息转发给其它对象, 则这个对象不能有negotiate方法. 否则, <code>forwardInvocation:</code>将不可能会被调用</p></blockquote><h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似, 可以用于为Objc编程添加一些多继承的效果. 就像下图那样, 一个对象把消息转发出去, 就好似它把另一个对象中的方法借过来或是“继承”过来一样</p><p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="">     </p><p>这使得不同继承体系分支下的两个类可以“继承”对方的方法, 在上图中Warrior和Diplomat没有继承关系, 但是Warrior将negotiate消息转发给了Diplomat后, 就好似Diplomat是Warrior的超类一样</p><p>消息转发弥补了 Objc 不支持多继承的性质, 也避免了因为多继承导致单个类变得臃肿复杂. 它将问题分解得很细, 只针对想要借鉴的方法才转发, 而且转发机制是透明的</p><h4 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h4><p>转发不仅能模拟多继承, 也能使轻量级对象代表重量级对象. 弱小的女人背后是强大的男人, 毕竟女人遇到难题都把它们转发给男人来做了. 这里有一些适用案例, 可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="noopener">官方文档</a></p><h4 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h4><p>尽管转发很像继承, 但是NSObject类不会将两者混淆<br>像<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>这类方法只会考虑继承体系, 不会考虑转发链. 比如上图中一个Warrior对象如果被问到是否能响应negotiate<br>消息:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>结果是NO, 尽管它能够接受negotiate消息而不报错, 因为它靠转发消息给Diplomat类来响应消息</p><p>如果你为了某些意图偏要“弄虚作假”让别人以为Warrior继承到了Diplomat的negotiate方法, 你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>来加入你的转发算法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Here, test whether the aSelector message can</span></span><br><span class="line"><span class="comment">       be forwarded to another object and whether that object can respond to it.</span></span><br><span class="line"><span class="comment">       Return YES if it can.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>之外, <code>instancesRespondToSelector:</code>中也应该写一份转发算法. 如果使用了协议, <code>conformsToProtocol:</code>同样也要加入到这一行列中. 类似地, 如果一个对象转发它接受的任何远程消息, 它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述, 这个方法会最终响应被转发的消息. 比如一个对象能给它的替代者对象转发消息, 它需要像下面这样实现<code>methodSignatureForSelector:</code>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">   <span class="keyword">if</span> (!signature)&#123;</span><br><span class="line">        signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a><span id="robust_instance">健壮的实例变量(Non Fragile ivars)</span></h2><p>在 Runtime 的现行版本中, 最大的特点就是健壮的实例变量. 当一个类被编译时, 实例变量的布局也就形成了, 它表明访问类的实例变量的位置. 从对象头部开始, 实例变量依次根据自己所占空间而产生位移:</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febhe6p56sj30cc039q36.jpg" alt=""></p><p>上图左边是NSObject类的实例变量布局, 右边是我们写的类的布局, 也就是在超类后面加上我们自己类的实例变量, 看起来不错. 但试想如果那天苹果更新了NSObject 类, 发布新版本的系统的话, 那就悲剧了:</p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1febhejwsvcj30cf03cmxk.jpg" alt=""></p><p>我们自定义的类被划了两道线, 那是因为那块区域跟超类重叠了. 唯有苹果将超类改为以前的布局才能拯救我们, 但这样也导致它们不能再拓展它们的框架了, 因为成员变量布局被死死地固定了. 在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性. 那么在健壮的实例变量下回发生什么呢？</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febhewc7doj30ci04rdge.jpg" alt=""></p><p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样, 但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移, 那样你在子类中新添加的成员就被保护起来了</p><p>需要注意的是在健壮的实例变量下, 不要使用<code>sizeof(SomeClass)</code>, 而是用<code>class_getInstanceSize([SomeClass class])</code>代替; 也不要使用<code>offsetof(SomeClass, SomeIvar)</code>, 而要用<code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code>来代替</p><h2 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a><span id="objc_Associated_obj">Objective-C Associated Objects</span></h2><p>在 OS X 10.6 之后, Runtime系统让Objc支持向对象动态添加变量. 涉及到的函数有以下三个:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</span><br></pre></td></tr></table></figure></p><p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值. 其中关联政策是一组枚举常量:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,         </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,            </span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这些常量对应着引用关联值的政策, 也就是 Objc 内存管理的引用计数机制</p><h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a><span id="method-swizzling">Method Swizzling</span></h2><p>之前所说的消息转发虽然功能强大, 但需要我们了解并且能更改对应类的源代码, 因为我们需要实现自己的转发逻辑. 当我们无法触碰到某个类的源代码, 却想更改这个类某个方法的实现时, 该怎么办呢？可能继承类并重写方法是一种想法, 但是有时无法达到目的. 这里介绍的是 Method Swizzling , 它通过重新映射方法对应的实现来达到“偷天换日”的目的. 跟消息转发相比, Method Swizzling 的做法更为隐蔽, 甚至有些冒险, 也增大了debug的难度</p><p>这里摘抄一个 NSHipster 的例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">       <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">       <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">      <span class="keyword">if</span> (didAddMethod)</span><br><span class="line">      &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">   [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>上面的代码通过添加一个Tracking 类别到UIViewController类中,  UIViewController 类的<code>viewWillAppear:</code> 方法和Tracking 类别中<code>xxx_viewWillAppear:</code> 方法的实现相互调换. Swizzling 应该在+load 方法中实现, 因为+load 是在一个类最开始加载时调用. dispatch_once 是GCD中的一个方法, 它保证了代码块只执行一次, 并让其为一个原子操作, 线程安全是很重要的</p><p>先用<code>class_addMethod</code>和<code>class_replaceMethod</code>函数将两个方法的实现进行调换, 如果类中已经有了<code>viewWillAppear:</code>方法的实现, 那么就调用<code>method_exchangeImplementations</code> 函数交换了两个方法的IMP, 这是苹果提供给我们用于实现 Method Swizzling 的便捷方法.</p><p>可能有人注意到了这行:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line"><span class="comment">// Class aClass = object_getClass((id)self);</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></span><br><span class="line"><span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></span><br></pre></td></tr></table></figure><p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 Class,但前者为元类, 后者为其本身, 因为此时 self 为 Class 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object class]</code> 的区别：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:如果类中没有想被替换实现的原方法时, <code>class_replaceMethod</code> 相当于直接调用 <code>class_addMethod</code> 向类中添加该方法的实现, 否则调用<code>method_setImplementation</code>方法, <code>types</code>参数会被忽略. <code>method_exchangeImplementations</code> 方法做的事情与如下的原子操作等价:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = method_getImplementation(m1);</span><br><span class="line">IMP imp2 = method_getImplementation(m2);</span><br><span class="line">method_setImplementation(m1, imp2);</span><br><span class="line">method_setImplementation(m2, imp1);</span><br></pre></td></tr></table></figure><p>最后<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环, 其实不会的. 因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现, 而它的实现已经被我们<code>viewWillAppear:</code>方法实现进行了互换, 所以这段代码不仅不会死循环, 如果你把<code>[self xxx_viewWillAppear:animated]</code>换成<code>[self viewWillAppear:animated]</code>反而会引发死循环</p><p>看到有人说<code>+load</code>方法本身就是线程安全的, 因为它在程序刚开始就被调用, 很少会碰到并发问题, 于是 StackOverFlow 上也有大神给出了另一个 Method Swizzling 的实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 is %@"</span>, arg1); [<span class="keyword">self</span> replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</span><br><span class="line">    SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">    Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod)))</span><br><span class="line">    &#123;</span><br><span class="line">       class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码同样要添加在某个类的类别中, 相比第一个种实现, 只是去掉了<code>dispatch_once</code> 部分. Method Swizzling 的确是一个值得深入研究的话题, Method Swizzling 的最佳实现是什么呢？小弟才疏学浅理解的不深刻, 找了几篇不错的资源推荐给大家:</p><p><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">JRSwizzle</a><br><a href="http://nshipster.com/method-swizzling" target="_blank" rel="noopener">Method Swizzling</a><br><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Objective-C的hook方案（一）: Method Swizzling</a><br><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="noopener">How do I implement method swizzling?</a><br><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a>   </p><p>在用 SpriteKit 写游戏的时候, 因为 API 本身有一些缺陷(增删节点时不考虑父节点是否存在啊, 很容易崩溃啊有木有!), 我在 Swift 上使用 Method Swizzling弥补这个缺陷:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleAddChild</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">"addChild:"</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">"yxy_addChild:"</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleRemoveFromParent</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">"removeFromParent"</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">"yxy_removeFromParent"</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">yxy_addChild</span><span class="params">(node: SKNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.yxy_addChild(node)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"This node has already a parent!\(node.name)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">yxy_removeFromParent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent != <span class="literal">nil</span> &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.yxy_removeFromParent()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"This node has no parent!\(name)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后其他地方调用那两个类方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SKNode.yxy_swizzleAddChild()</span><br><span class="line">SKNode.yxy_swizzleRemoveFromParent()</span><br></pre></td></tr></table></figure></p><p>因为 Swift 中的 extension 的特殊性, 最好在某个类的 `load()`` 方法中调用上面的两个方法. 我是在AppDelegate 中调用的, 于是保证了应用启动时能够执行上面两个方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="summary">总结</span></h2><p>我们之所以让自己的类继承NSObject 不仅仅因为苹果帮我们完成了复杂的内存分配问题, 更是因为这使得我们能够用上 Runtime 系统带来的便利. 可能我们平时写代码时可能很少会考虑一句简单的<code>[receiver message]</code> 背后发生了什么, 而只是当做方法或函数调用. 深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码, 比如 Method Swizzling 等   </p><p>参考链接:<br><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="noopener">Objective-C runtime之运行时的基本特点</a><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming  Guide</a><br><a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">Understanding the Objective-C Runtime</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转自杨萧玉博客: &lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;玉令天下&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文详细整理了 &lt;strong&gt;Cocoa&lt;/strong&gt; 的 &lt;strong&gt;Runtime&lt;/strong&gt; 系统的知识, 它使得 &lt;strong&gt;Objective-C&lt;/strong&gt; 如虎添翼, 具备了灵活的动态特性, 使这门古老的语言焕发生机&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://oneofai.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>制作自己的 Pods 依赖库</title>
    <link href="http://oneofai.com/2015/04/10/2015-04-10-%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84-pods-%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
    <id>http://oneofai.com/2015/04/10/2015-04-10-制作自己的-pods-依赖库/</id>
    <published>2015-04-10T14:45:10.000Z</published>
    <updated>2018-01-15T16:10:40.222Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="noopener">CocoaPods</a> 的所有 <code>Pods</code> 都托管在 <code>GitHub</code> 上, 如果要制作呢, 第一步我们就要创建我们的<code>GitHub</code>仓库, 以<a href="https://github.com/oneofai/AIAttributedString" target="_blank" rel="noopener">AIAttributedString</a> 为例</p><a id="more"></a> <h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p><code>add .gitignore</code> 选择 <code>Objective-C</code>, <code>Add a license</code> 选择 <code>MIT License</code>   </p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fed81km89xj316g0y479y.jpg" alt=""></p><p>创建完毕后, <code>copy</code> 仓库链接按钮, 使用 HTTPS, 因为 <code>CocoaPods</code> 要求使用 <code>HTTPS</code>, 不然会有不安全的警告</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fed82cqkgfj30k2098wfo.jpg" alt=""></p><p>然后把仓库<code>clone</code>到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oneofai/AIAttributedString.git</span><br></pre></td></tr></table></figure><h3 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h3><h4 id="1-创建-podspec-文件"><a href="#1-创建-podspec-文件" class="headerlink" title="1. 创建 .podspec 文件"></a>1. 创建 .podspec 文件</h4><p><code>Pods</code> 都要依赖一个扩展名为 <code>.podspec</code> 的描述文件, 文件的名称要和依赖库的名字保持一致, 所以我们的文件名为: <code>AIAttributedString.podspec</code>, 内容如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name         = <span class="string">"AIAttributedString"</span></span><br><span class="line">  s.version      = <span class="string">"0.0.1"</span></span><br><span class="line">  s.summary      = <span class="string">"a custom attribute string category."</span></span><br><span class="line">  s.description  = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">  a attribute string category used on iOS.</span></span><br><span class="line"><span class="string">                   DESC</span></span><br><span class="line">  s.homepage     = <span class="string">"https://github.com/oneofai/AIAttributedString"</span></span><br><span class="line"></span><br><span class="line">  s.license      = <span class="string">"MIT"</span></span><br><span class="line">  s.author             = &#123; <span class="string">"oneofai"</span> =&gt; <span class="string">"youremail@gmail.com"</span> &#125;</span><br><span class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"8.0"</span></span><br><span class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://github.com/oneofai/AIAttributedString.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"<span class="subst">#&#123;s.version&#125;</span>"</span> &#125;</span><br><span class="line"></span><br><span class="line">  s.source_files  = <span class="string">"AIAttributedString"</span>, <span class="string">"AIAttributedString/**/*.&#123;h,m&#125;"</span></span><br><span class="line">  s.frameworks = <span class="string">"Foundation"</span>, <span class="string">"UIKit"</span></span><br><span class="line">  s.requires_arc = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>当然你也可以使用命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create AIAttributedString</span><br></pre></td></tr></table></figure><p>但是这样 <code>CocoaPods</code> 帮你生成的 <code>.podspec</code> 文件中会包含所有条目, 其中很多我们并不需要, 你可以拷贝上边我的条目, 把相关地方改了就可以了</p><h4 id="2-关于-License"><a href="#2-关于-License" class="headerlink" title="2. 关于 License"></a>2. 关于 License</h4><p><code>CocoaPods</code> 强制要求所有的 <code>Pods</code> 依赖库都必须有<code>License</code>文件, 否则验证不会通过, 你可以在创建仓库的时候自动选择加上 <code>License</code> 文件, 一般使用 <code>MIT License</code> 即可, 我们上边创建仓库的时候就要已经勾选了, 所以这一步我们就可以略掉了</p><h4 id="3-依赖库"><a href="#3-依赖库" class="headerlink" title="3. 依赖库"></a>3. 依赖库</h4><p>你想把哪些文件作为依赖库的文件共享给他人使用, 就把相应的文件放到一个文件夹就可以了, 在此, 我们在当前目录下再创建一个和依赖库名称相同的文件夹 <code>AIAttributedString</code> , 然后把库文件放进去, 现在目录结构如下</p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fedeziiavej30na05caaz.jpg" alt=""></p><p>一般呢, 别人制作的库中都 <code>Demo</code> , 因为我已经写好了, 所以就一同放在文件夹里了, 正确的步骤是先创建好 <code>Demo</code>, 再做这些操作, 因为你不可能连库都没写好, 就去制作 <code>Pods</code> 的对吧, 肯定是写好了库, 再去分享</p><h2 id="测试提交"><a href="#测试提交" class="headerlink" title="测试提交"></a>测试提交</h2><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>经过了上边的步骤, 我们还需要一步, 就是用 <code>CocoaPods</code> 的命令去验证我们的库, 没做验证是不能提交的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure><p>如果一切正常, 这条命令执行完后会呈现出下边的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; AIAttributedString (0.0.1)</span><br><span class="line"></span><br><span class="line">AIAttributedString passed validation.</span><br></pre></td></tr></table></figure><p>如果有任何, 比如说<code>方法过期</code>、<code>未使用 HTTPS 链接</code>、<code>.podspec 文件有语法错误</code>, 或者是任何字段填写不正确, 它都会在这里以<code>[warning]</code>和<code>[error]</code>提示你, 提示很详细, 你根据提示的内容去修改相应的地方, 或者把关键字丢进 <code>Google</code> 查一下就好了</p><h4 id="上传到-GitHub"><a href="#上传到-GitHub" class="headerlink" title="上传到 GitHub"></a>上传到 GitHub</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m <span class="string">"version 0.0.1"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>给仓库打上标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 0.0.1</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>不出什么意外的话, 代码已经 <code>push</code> 到<code>GitHub</code> 的远端仓库了</p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fedfbaf2erj31j60gaadx.jpg" alt=""></p><p>做完上边的操作, 依赖库还不能使用 <code>CocoaPods</code> 安装使用, 因为它只是在 <code>GitHub</code> 上, 这时我们只需要将<code>.podspec</code> 文件上传到 <code>CocoaPods</code> 的 <a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">Specs仓库</a> 中即可</p><h4 id="添加-podspec-文件到-Specs-仓库"><a href="#添加-podspec-文件到-Specs-仓库" class="headerlink" title="添加 .podspec 文件到 Specs 仓库"></a>添加 .podspec 文件到 Specs 仓库</h4><p>因为 <code>Specs</code> 这个仓库并非我们创建的, 而是 <code>CocoaPods</code> 官方创建的, 我们并不能随意的往里 <code>push</code> 文件, 而</p><blockquote><p>fork 一份, 添加修改, 然后 push 给原作者, 等待审核, 这条路已经被堵死了…</p></blockquote><p><code>CocoaPods</code>  为我们提供了一个更为安全的方法 <a href="http://blog.cocoapods.org/CocoaPods-Trunk/#transition" target="_blank" rel="noopener">trunk</a></p><blockquote><p>需要代理</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register youremail@gmail.com <span class="string">'yourname'</span> --description=<span class="string">'stuff'</span> --verbose</span><br></pre></td></tr></table></figure><p>其中 <code>youremail</code> 改为你自己的 <code>email</code>, <code>yourname</code> 改成你的名字, <code>description</code> 按需填写, 执行完成后呢, 如果你是第一次使用 <code>trunk</code>, 会需要一封邮件确认, 提示如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] Please verify the session by clicking the link <span class="keyword">in</span> the verification email that has been sent to youremail@gmail.com</span><br></pre></td></tr></table></figure></p><p>然后去邮箱查看邮件确认即可</p><p>通过如下命令, 查看你注册的 <code>trunk</code> 信息, 包括注时间、邮箱、发布过的 Pods 等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure><p>然后提交我们的 <code>.podspec</code> 文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push AIAttributedString.podspec</span><br></pre></td></tr></table></figure></p><p>这条命令做了如下三件事</p><ol><li>验证本地的 <code>podspec</code>文件, 我们上边使用 <code>pod lib lint</code> 验证过一次了</li><li>上传 <code>.podspec</code> 文件到 trunk 服务</li><li>将 <code>.podspec</code> 文件转为 <code>.podspec.json</code> 文件</li></ol><p>如果没有什么报错的话, 会有如下提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Updating spec repo `master`</span><br><span class="line">Validating podspec</span><br><span class="line"> -&gt; AIAttributedString (0.0.1)</span><br><span class="line"></span><br><span class="line">Updating spec repo `master`</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">🎉  Congrats</span><br><span class="line"></span><br><span class="line">🚀  AIAttributedString (0.0.1) successfully published</span><br><span class="line">📅  April 10th, 17:16</span><br><span class="line">🌎  https://cocoapods.org/pods/AIAttributedString</span><br><span class="line">👍  Tell your friends!</span><br></pre></td></tr></table></figure></p><p>我们的 <code>Pods</code> 就制作完成了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod setup</span><br><span class="line">pod search AIAttributedString</span><br></pre></td></tr></table></figure><p>应该就可以找到了</p><p>让你需要让别人帮助你维护依赖库时, 可以提供权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk add-owner AIAttributedString otheremail@gmail.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CocoaPods/CocoaPods&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPods&lt;/a&gt; 的所有 &lt;code&gt;Pods&lt;/code&gt; 都托管在 &lt;code&gt;GitHub&lt;/code&gt; 上, 如果要制作呢, 第一步我们就要创建我们的&lt;code&gt;GitHub&lt;/code&gt;仓库, 以&lt;a href=&quot;https://github.com/oneofai/AIAttributedString&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AIAttributedString&lt;/a&gt; 为例&lt;/p&gt;
    
    </summary>
    
      <category term="CocoaPods" scheme="http://oneofai.com/categories/CocoaPods/"/>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/CocoaPods/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="CocoaPods" scheme="http://oneofai.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中控制器间逆向传值的三种方式</title>
    <link href="http://oneofai.com/2015/02/11/2015-02-11-ios-%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E9%97%B4%E9%80%86%E5%90%91%E4%BC%A0%E5%80%BC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://oneofai.com/2015/02/11/2015-02-11-ios-中控制器间逆向传值的三种方式/</id>
    <published>2015-02-11T09:09:08.000Z</published>
    <updated>2018-01-15T16:11:53.931Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中, 我们在两个控制器之间正向传数据的时候, 一般使用的是属性(property), 这样最简单, 最方便, 性能也好</p><a id="more"></a> <blockquote><p>但有时候, 或者说有很多时候, 我们需要逆向传递数据, 也就是当前控制器Dismiss返回上一个控制器时, 在当前控制器处理过的数据需要返回给Source Controller ,这种数据传递, 在OC中一般有三种方式: 通知、代理、Block</p></blockquote><h4 id="1-通知"><a href="#1-通知" class="headerlink" title="1. 通知"></a>1. 通知</h4><p>在第二个控制器触发Dismiss时, 发出通知, 同时<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)clickDismissButton:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"buttonData"</span> object:<span class="literal">nil</span> userInfo:@&#123;<span class="string">@"button"</span>:button&#125;];</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>]; <span class="comment">//也可以在completion的block发出此通知,在此我们不使用回调,给的nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个控制器监听此通知即可<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(setTitleText:) name:<span class="string">@"buttonData"</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTitleText:(<span class="built_in">NSNotification</span> *)notify</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *button = notify.userInfo[<span class="string">@"button"</span>];</span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.text = button.currentTitle; <span class="comment">//我们修改了第一个控制器上一个label的text和背景颜色</span></span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.backgroundColor = button.backgroundColor;</span><br><span class="line">&#125;<span class="comment">//通知其实很简单</span></span><br></pre></td></tr></table></figure></p><h4 id="2-代理"><a href="#2-代理" class="headerlink" title="2. 代理"></a>2. 代理</h4><p>因为我们目的是要给第一个控制器传递数据修改属性, 但是第二个控制器做不到修改第一个控制器控件属性这件事儿, 所以, 我们需要在第二个控制器写出协议, 并设置代理属性, 在第一个控制器设置代理, 遵循协议, 实现方法, 也很简单</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">HOModalController</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HOModalControllerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)modalController:(HOModalController *)modalVC withButton:(<span class="built_in">UIButton</span> *)button;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HOModalController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;HOModalControllerDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>并在.m文件中调用代理方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(modalController:withButton:)])</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.delegate modalController:<span class="keyword">self</span> withButton:button];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在第一个控制控制器中实现代理方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)modalController:(HOModalController *)modalVC withButton:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.text = button.currentTitle;</span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.backgroundColor = button.backgroundColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-Block"><a href="#3-Block" class="headerlink" title="3. Block"></a>3. Block</h4><p>在控制器dismiss的时候, 调用block传值, 首先, 我们在第二个控制器定义一个外部可访问的block属性, 也就是.h文件里<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="keyword">void</span>(^modalBlock)(<span class="built_in">UIButton</span> *button);</span><br></pre></td></tr></table></figure></p><p>然后在.m文件中给此属性赋值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.modalBlock(button);</span><br></pre></td></tr></table></figure></p><p>接着在第一个控制器中调用这个属性即可<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modalVC.modalBlock = ^(<span class="built_in">UIButton</span> *button)&#123;</span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.text = button.currentTitle;</span><br><span class="line">    <span class="keyword">self</span>.receiveLabel.backgroundColor = button.backgroundColor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中, 我们在两个控制器之间正向传数据的时候, 一般使用的是属性(property), 这样最简单, 最方便, 性能也好&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>couldn&#39;t find a common superview</title>
    <link href="http://oneofai.com/2015/02/05/2015-02-05-couldn-t-find-a-common-superview/"/>
    <id>http://oneofai.com/2015/02/05/2015-02-05-couldn-t-find-a-common-superview/</id>
    <published>2015-02-05T03:20:29.000Z</published>
    <updated>2018-01-15T16:11:46.298Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h4 id="console报错信息"><a href="#console报错信息" class="headerlink" title="console报错信息"></a>console报错信息</h4><blockquote><p>couldn’t find a common superview for &lt;UIScrollView: 0x7fb8a401ac00; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = <nsarray: 0x7fb8a3c17990="">; layer = <calayer: 0x7fb8a3c235a0="">; contentOffset: {0, 0}; contentSize: {0, 0}&gt; and &lt;UIView: 0x7fb8a3c1c970; frame = (0 0; 375 667); autoresize = W+H; layer = <calayer: 0x7fb8a3c15ff0="">&gt;</calayer:></calayer:></nsarray:></p></blockquote><hr><h4 id="大致原因"><a href="#大致原因" class="headerlink" title="大致原因"></a>大致原因</h4><p>不能为scrollView找到父视图, 原因为当scrollView被创建后, 使用masonry对scrollView进行设置约束时会找视图进行参考, 我们这里是以其父视图view进行参考, 但此时scrollView并未添加到view中, 所以运行会直接崩掉</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>修改添加到父控件的代码的执行顺序即可</p><h4 id="原代码"><a href="#原代码" class="headerlink" title="原代码:"></a>原代码:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScrollView</span> *scrollView = <span class="built_in">UIScrollView</span>.new;   </span><br><span class="line">scrollView.backgroundColor = [<span class="built_in">UIColor</span> brownColor];   </span><br><span class="line">[scrollView mas_makeConstraints:^(MASConstraintMaker *make)</span><br><span class="line">&#123;</span><br><span class="line">       make.size.mas_equalTo(<span class="keyword">self</span>.view);   </span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:scrollView];</span><br></pre></td></tr></table></figure><h4 id="改正后"><a href="#改正后" class="headerlink" title="改正后:"></a>改正后:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScrollView</span> *scrollView = <span class="built_in">UIScrollView</span>.new;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:scrollView];  <span class="comment">//放到这里</span></span><br><span class="line">scrollView.backgroundColor = [<span class="built_in">UIColor</span> brownColor];   </span><br><span class="line">[scrollView mas_makeConstraints:^(MASConstraintMaker *make)</span><br><span class="line">&#123;</span><br><span class="line">      make.size.mas_equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h4 id=&quot;console报错信息&quot;&gt;&lt;a href=&quot;#console报错信息&quot; class=&quot;headerlink&quot; title=&quot;console报错信息&quot;&gt;&lt;/a&gt;console报错信息&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;co
      
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>The sandbox is not sync with the Podfile.lock</title>
    <link href="http://oneofai.com/2015/02/01/2015-02-01-the-sandbox-is-not-sync-with-the-podfile-lock/"/>
    <id>http://oneofai.com/2015/02/01/2015-02-01-the-sandbox-is-not-sync-with-the-podfile-lock/</id>
    <published>2015-02-01T05:14:23.000Z</published>
    <updated>2018-01-15T16:10:54.675Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <p>github下载的Demo, 很多时候使用到pods, 有的时候因为依赖关系或者版本问题不能编译运行. 出现如 <code>The sandbox is not sync with the Podfile.lock</code> 问题的时候, 如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff: /../Podfile.lock: No such file or directory</span><br><span class="line">diff: Manifest.lock: No such file or directory</span><br><span class="line">error: The sandbox is not <span class="keyword">in</span> sync with the Podfile.lock.   </span><br><span class="line">Run <span class="string">'pod install'</span> or update your CocoaPods installation.</span><br></pre></td></tr></table></figure><p>解决方法：</p><blockquote><p>关闭当前的项目, 删掉项目文件夹中的<code>.xcworkspace</code>, 重新pod install, install 完成之后, 通过新生成的<code>.xcworkspace</code>打开项目, clean+build即可, 如下所示</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf MyProject.xcworkspace</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;p&gt;github下载的Demo, 很多时候使用到pods, 有的时候因为依赖关系或者版本问题不能编译运行. 出现如 &lt;code&gt;The sandbox is not sync with the Podfile.lock&lt;/code&gt; 问题的
      
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Github" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/Github/"/>
    
      <category term="CocoaPods" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/Github/CocoaPods/"/>
    
    
      <category term="Github" scheme="http://oneofai.com/tags/Github/"/>
    
      <category term="CocoaPods" scheme="http://oneofai.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>以优雅的方式使用终端</title>
    <link href="http://oneofai.com/2014/11/06/2014-11-06-%E4%BB%A5%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF/"/>
    <id>http://oneofai.com/2014/11/06/2014-11-06-以优雅的方式使用终端/</id>
    <published>2014-11-06T08:13:03.000Z</published>
    <updated>2018-01-15T16:11:05.436Z</updated>
    
    <content type="html"><![CDATA[<p>可能因为以前玩 Linux 的缘故, 看终端很顺眼, 我个人是比较喜欢用终端搞事情的<del>装起逼来也显得比较高端</del>, 但 OS X 自带的终端有很多东西不是特别的好用, 正巧前段时间看了池老师的<a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 shell</a>, 于是闲下来折腾一下自己的 <code>Shell</code></p><a id="more"></a> <p><code>Shell</code> 交互当然有缺点, 比如看起来很难懂啦、全是文字不够直观啦、不美观啦等等, 今天要讲的就是如何让它看上去和用上更优雅. 其实 <code>Shell</code> 也有很多优点, 比如它可以和内核直接进行交互, 省去了很多性能在 GUI 界面上的浪费, 因为 GUI 界面与内核交互, 中间很多时候也是要通过 <code>Shell</code>, 只不过没让你看见, 所以说, 真正干活的是 <code>Kernel</code>, GUI 就是为了让你直观的理解与观察</p><p><strong>下面开始正题</strong></p><hr><p>OS X 本身提供了很多 <code>Shell</code>, 默认的是 <code>bash</code>, 我们可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure></p><p>进行查看系统提供了哪些 <code>Shell</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List of acceptable shells for chpass(1).</span></span><br><span class="line"><span class="comment"># Ftpd will not allow users to connect who are not using</span></span><br><span class="line"><span class="comment"># one of these shells.</span></span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>需要说明的是, 世界上不止这几种 <code>Shell</code>, 存在着很多小众的 <code>Shell</code>, 之所以小众, 可能是因为开发它的人目标性很强, 并不通用, 可能也并未想让它通用, 以上这几种是 OS X 中内置的 <code>Shell</code></p><p>OS X 中系统默认提供的是<code>bash</code>, 我们可以通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line"><span class="comment">#注: 这个用法不是所有 Shell 都支持</span></span><br></pre></td></tr></table></figure></p><p>来查看当前的 <code>Shell</code></p><p>但其实, <code>bash</code> 并不是最强大的 <code>Shell</code>, 最强大的是 <code>zsh</code>, 它可以兼容 <code>bash</code>, 并且提供了很多 <code>bash</code> 没有的特性和功能, 但其本身配置相当复杂, 所以用的人很少, 鉴于其优秀的特性于是有个叫 <a href="https://github.com/robbyrussell" target="_blank" rel="noopener">robbyrussell</a> 的哥们开发出了<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>, 这个就厉害了, 而且配置容易了很多</p><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>囿于 OS X 本身提供的 Terminal 太简单, 可定制项太少, 达不到定制的要求, 所以呢, 我们先去安装一个更好用的终端模拟器: <a href="http://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a>, 安装方式有很多, 你<a href="http://www.iterm2.com/downloads.html" target="_blank" rel="noopener">点这里</a>直接下载<code>zip</code>压缩包, 解压后拖进 <code>Applications</code> 里可以, 使用 <code>homebrew</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install iterm2</span><br></pre></td></tr></table></figure></p><p>也可以, 或者在终端中使用 <code>wget</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gnachman/iTerm2/archive/v2.0.0.20141103.zip</span><br></pre></td></tr></table></figure></p><p>也可以, whatever you want…总之, 你开心就好了</p><h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h2><p>iTerm2 默认提供的是 <code>Dark</code> 主题, 本身还是蛮不错的, 不过我觉得太单调了点儿, 于是我自己配置了好久, 但无奈都不太理想, 恰巧正好在 GitHub 上发现了这么一款, 很符合我的胃口 <a href="https://github.com/raphamorim/lucario" target="_blank" rel="noopener">Lucario</a> , 我自己在它原有的基础稍稍修改了一些颜色, 看上去还不错</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1feczwy9ub2j30zk0tc76t.jpg" alt=""></p><p>之后我们需要切换到 <code>zsh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h2 id="再次"><a href="#再次" class="headerlink" title="再次"></a>再次</h2><p>我们安装更简单的 oh-my-zsh, 当然和 <code>iterm2</code> 一样, 安装方式也有很多, 你可以去 GitHub 下载源码, 通过执行<code>tools</code>文件夹中的 <code>install.sh</code> 来安装, 也可以通过 <code>brew install oh-my-zsh</code> 来安装, 或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><p>都一样, 接着拷贝 <code>oh-my-zsh</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h3><p><code>oh-my-zsh</code> 的配置基本都集中在<code>~/.zshrc</code>这个文件内, <code>vim</code> 打开之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1fed3q02pfzj30yo07ydhp.jpg" alt=""></p><p><code>oh-my-zsh</code> 默认提供的是 <code>robbyrussell</code> 这个主题, 说明一下, 这是 <code>zsh</code>的主题, 也就是 <code>Shell</code> 的主题, 区别于 <code>iTerm2</code>的配色方案, 这两个是不同的东西, <code>iTerm2</code>相当于衣服一样, 包裹着 <code>Shell</code></p><p>我没有使用自带的主题 <del>没错, 我就是这么喜欢与众不同</del>, 我使用的我根据 <code>ys.zsh-theme</code> 这个主题自己定义的, 修改了 <code>Prompt</code> 的一些东西, 下面是我的 <code>zsh-theme</code> 主题配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VCS</span></span><br><span class="line">ONEOFAI_VCS_PROMPT_PREFIX1=<span class="string">" %&#123;<span class="variable">$fg</span>[white]%&#125;on%&#123;<span class="variable">$reset_color</span>%&#125; "</span></span><br><span class="line">ONEOFAI_VCS_PROMPT_PREFIX2=<span class="string">":%&#123;<span class="variable">$fg</span>[cyan]%&#125;"</span></span><br><span class="line">ONEOFAI_VCS_PROMPT_SUFFIX=<span class="string">"%&#123;<span class="variable">$reset_color</span>%&#125;"</span></span><br><span class="line">ONEOFAI_VCS_PROMPT_DIRTY=<span class="string">" %&#123;<span class="variable">$fg</span>[red]%&#125;x"</span></span><br><span class="line">ONEOFAI_VCS_PROMPT_CLEAN=<span class="string">" %&#123;<span class="variable">$fg</span>[green]%&#125;o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git info</span></span><br><span class="line"><span class="built_in">local</span> git_info=<span class="string">'$(git_prompt_info)'</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">"<span class="variable">$&#123;ONEOFAI_VCS_PROMPT_PREFIX1&#125;</span>git<span class="variable">$&#123;ONEOFAI_VCS_PROMPT_PREFIX2&#125;</span>"</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_SUFFIX</span>"</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_DIRTY</span>"</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_CLEAN</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HG info</span></span><br><span class="line"><span class="built_in">local</span> hg_info=<span class="string">'$(oneofai_hg_prompt_info)'</span></span><br><span class="line"><span class="function"><span class="title">oneofai_hg_prompt_info</span></span>() &#123;</span><br><span class="line">    <span class="comment"># make sure this is a hg dir</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">'.hg'</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$&#123;ONEOFAI_VCS_PROMPT_PREFIX1&#125;</span>hg<span class="variable">$&#123;ONEOFAI_VCS_PROMPT_PREFIX2&#125;</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> -n $(hg branch 2&gt;/dev/null)</span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$(hg status 2&gt;/dev/null)</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_DIRTY</span>"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_CLEAN</span>"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$ONEOFAI_VCS_PROMPT_SUFFIX</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> exit_code=<span class="string">"%(?,,C:%&#123;<span class="variable">$fg</span>[red]%&#125;%?%&#123;<span class="variable">$reset_color</span>%&#125;) "</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt format:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PRIVILEGES USER @ MACHINE in DIRECTORY on git:BRANCH STATE [TIME] C:LAST_EXIT_CODE</span></span><br><span class="line"><span class="comment"># $ COMMAND</span></span><br><span class="line"><span class="comment"># For example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># % oneofai in ~/.oh-my-zsh on git:master x &gt;                 [17:30]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">ONEOFAI_SHORT_DATE_FORMAT=<span class="string">"["</span>$(date <span class="string">"+%H:%M"</span>)<span class="string">"]"</span></span><br><span class="line">PROMPT=<span class="string">"%(#,%&#123;<span class="variable">$bg</span>[yellow]%&#125;%&#123;<span class="variable">$fg</span>[black]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125;,%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n) \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;%~%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span>\</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125; &gt; %&#123;<span class="variable">$reset_color</span>%&#125;"</span></span><br><span class="line"></span><br><span class="line">RPROMPT=<span class="string">"%&#123;<span class="variable">$fg</span>[blue]%&#125;<span class="variable">$ONEOFAI_SHORT_DATE_FORMAT</span>"</span></span><br></pre></td></tr></table></figure></p><p>如果你想修改主题呢, 可以去<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">oh-my-zsh Themes</a>看下, 这里都是 <code>iTerm2</code> 本身内置的一些主题, 路径在 <code>~/.oh-my-zsh/theme</code> 下, 然后挑选一个自己喜欢的, 如果觉得这里没有你中意的, 也可以去这里 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" target="_blank" rel="noopener">oh-my-zsh External-themes</a> 自己下载之后放到 <code>~/.oh-my-zsh/theme</code> 下, 然后把 <code>~/.zshrc</code> 的 <code>ZSH_THEME</code> 改为你想用的主题的名字<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"主题名字"</span></span><br></pre></td></tr></table></figure></p><p>当然你也可以像我一样, 自己定义一款属于你自己的主题 😊, 不要被上边那一大段吓到, 其实就是 <code>Shell</code> 的脚本</p><h3 id="关于插件"><a href="#关于插件" class="headerlink" title="关于插件"></a>关于插件</h3><p><code>oh-my-zsh</code> 本身提供了很多<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins" target="_blank" rel="noopener">插件</a>可供选择, 但是很多默认都没有启用, 你可以自己启用, 下图是我自己的插件列表</p><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fed3oncnwxj30za06kmzu.jpg" alt=""></p><p>其中 <code>alias</code>、<code>extract</code>、<code>git</code>、<code>autojump</code>、<code>zsh-syntax-highlighting</code>, 我这几个插件是比较常用的, 我分别解释一下</p><blockquote><p><code>alias</code> :自动设置别名, 比如<code>l=ls -lah</code>、<code>la= ls -a</code>、<code>h=history</code>等<br><code>extract</code> :可以使用 <code>x</code> 命令自动解压像 <code>.tar</code>、<code>.tar.gz</code>、<code>.zip</code>等文件, 不需要再多余的指令<br><code>git</code> :当你处于一个 <code>git</code> 受控的目录下时，Shell 会明确显示 <code>git</code> 和 <code>branch</code>, 另外还对 git 很多命令进行了简化，例如 <code>ga=git add</code>、<code>gd=git diff</code>等<br><code>autojump</code> :是自动跳转的插件, 它可以让你快速的跳转刚刚访问的目录, 例如<code>j projects</code> 它会快速跳转到刚刚访问的路径中带有<code>projects</code>字样的目录,这个插件需要手动安装, 你可以通过 <code>brew install autojump</code>进行安装, <code>zsh</code> 本身没有内置<br><code>zsh-syntax-highlighting</code> :是命令语法高亮的插件, 如果输入的命令正确, 它默认会以绿色显示, 错误以红色显示</p></blockquote><h3 id="关于环境变量"><a href="#关于环境变量" class="headerlink" title="关于环境变量"></a>关于环境变量</h3><p><code>oh-my-zsh</code> 本身在安装的时候会自动读取当前环境变量进行设置, 如果你觉得还不够呢, 可以自己追加, 下图是我的环境变量</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fed3piqakaj30yo0dm0vy.jpg" alt=""></p><p><code>zsh</code> 不仅仅可以设置别名, 还可以针对文件类型设置对应的打开程序, 例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> -s html=atom</span><br></pre></td></tr></table></figure></p><p><code>alias -s html=atom</code> 意为当你在终端中直接输入扩展名为<code>.html</code>的文件名字的时候, 比如 <code>index.html</code>, 它会直接用 <code>Atom</code> 这个应用打开, 非常方便</p><p>以上这些都是基本配置, 基本平常使用就无大碍了, 下边说一些<code>zsh</code>和<code>iterm</code>技巧性的东西</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="关于-iTerm"><a href="#关于-iTerm" class="headerlink" title="关于 iTerm"></a>关于 iTerm</h3><ul><li>在 iTerm 的 <code>Preferences</code> - <code>Keys</code> - <code>Hotkey</code> - <code>Hotkey toggles a dedicated window with profile:</code> 设置一个用户热键呼出的 <code>profile</code>, 即可通过快捷键从屏幕边缘呼出, 并且还可以设置呼出的样式, 从上边从下边从左从右, 任君选择, 很是炫酷</li><li><code>⌘ + 左键单击</code> :可以打开文件, 文件夹和链接</li><li><code>⌘ + t</code> :新建标签页(这应该是OS X下几乎所有软件的默认 keymap)</li><li><code>⌘ + 数字</code> &amp; <code>⌘ + 方向键</code> : 切换标签页</li><li><code>⌘ + d</code> :左右分屏</li><li><code>⇧ + ⌘ + d</code> :上下分屏</li><li><code>⌘ + /</code> :显示光标位置</li><li>快捷键有很多啦, 想了解的话可以去看下 <code>iTerm</code> 的设置, 里边都有标出<br><img src="https://ww3.sinaimg.cn/large/006tNc79ly1fed2xuugstj31g20sydoa.jpg" alt=""></li><li>另外, 它的 <code>Show Tips of the Day</code> 很有意思</li></ul><h3 id="关于-zsh"><a href="#关于-zsh" class="headerlink" title="关于 zsh"></a>关于 zsh</h3><ul><li>可以省略 <code>cd</code> 命令</li><li>连续按 <code>tab</code> 可以直接选择文件及文件夹</li><li>kill <tab> 会自动列出所有进程, 也可以用 kill aria2 <tab> , 它会列出 aria2 的  PID</tab></tab></li><li>输入一个命令, 按方向键上下翻,可以列出你所使用这个命令的历史记录, 例如<code>brew</code> + <code>↑</code>, 可以查看你使用 <code>brew</code>开头的所有命令, 很是好用</li><li>输入 d, 可列出你在这个会话里访问的目录列表, 比如你在当前 <code>/WorkSpace</code> 访问了另一个文件夹下<code>/Downloads</code>目录, 它会记录下来, 输入列表前的序号，即可直接跳转</li><li><code>l **/*</code> 可以递归显示当前目录下的文件及目录</li><li>使用 <code>colored-man-pages</code> 这个插件可以以彩色方式来查看 <code>man</code>页面</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>我个人使用的是 <code>shadowsocks</code> , <code>http</code> 和 <code>socks5</code> 两种方式都用</p><p>想要 <code>iTerm2</code> 走代理的话, 只需要在 <code>~/.zshrc</code> 中添加如下命令即可</p><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1fed4p2d3nrj30yu02sdge.jpg" alt=""></p><p>或者直接在终端中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:9090 <span class="comment">#9090 换成你自己的代理端口</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:9090  <span class="comment">#ss 默认是1080</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能因为以前玩 Linux 的缘故, 看终端很顺眼, 我个人是比较喜欢用终端搞事情的&lt;del&gt;装起逼来也显得比较高端&lt;/del&gt;, 但 OS X 自带的终端有很多东西不是特别的好用, 正巧前段时间看了池老师的&lt;a href=&quot;http://macshuo.com/?p=676&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;终极 shell&lt;/a&gt;, 于是闲下来折腾一下自己的 &lt;code&gt;Shell&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OS X" scheme="http://oneofai.com/categories/OS-X/"/>
    
    
      <category term="OS X" scheme="http://oneofai.com/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa 与 Cocoa Touch 的区别</title>
    <link href="http://oneofai.com/2014/10/15/2014-10-15-cocoa-%E4%B8%8E-cocoa-touch-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://oneofai.com/2014/10/15/2014-10-15-cocoa-与-cocoa-touch-的区别/</id>
    <published>2014-10-14T16:17:45.000Z</published>
    <updated>2018-01-15T16:11:15.373Z</updated>
    
    <content type="html"><![CDATA[<p>两者都包含 OC 运行时的两个核心框架:   </p><ul><li>Cocoa 包含 Foundation 和 AppKit 框架, 可用于开发 Mac OS X 系统的应用程序</li></ul><a id="more"></a> <h2 id="Cocoa-Touch-包含-Foundation-和-UIKit-框架-可用于开发-iOS-系统的应用程序"><a href="#Cocoa-Touch-包含-Foundation-和-UIKit-框架-可用于开发-iOS-系统的应用程序" class="headerlink" title="- Cocoa Touch 包含 Foundation 和 UIKit 框架, 可用于开发 iOS 系统的应用程序"></a>- Cocoa Touch 包含 Foundation 和 UIKit 框架, 可用于开发 iOS 系统的应用程序</h2><p>但 Cocoa 是 Mac OS X 的开发环境, Cocoa Touch 是 iOS 的开发环境      </p><p>Foundation 框架实现了 <code>NSObject</code> 类(即根类), 这个类定义基本对象行为, 此外, 该框架还实现了用于表示基本类型(例如, 字符串和数字)和群体类型(例如数组和字典)的类, 同时也提供一些基本工具, 例如用于<a href="http://mobile.51cto.com/iphone-274574.htm" target="_blank" rel="noopener">国际化</a>, 对象持久化, 文件管理以及 <code>XML</code> 文件处理的工具. 你还可以使用 Foundation 框架中的类访问地层系统的实体和服务, 例如可以用它来访问端口、线程、锁和进程. Foundation 框架以 <code>Core Foundation</code> 框架为基础. <code>Core Foundation</code> 框架提供的是过程化(ANSI C)接口</p><p>AppKit 和 UIKit 可以被用来开发应用程序的接口. 二者用途相同, 区别在平台不同</p><p>框架中的类很多, 各种不同用途: 有的用于事件处理, 有的用于画图, 有的用于图像处理, 有的用于文本处理, 有的用于用户排版, 还有用于应用程序之间的数据传输</p><p>框架中还包含表视图、滑动条、按键、文本字段以及警告对话框等用户的接口元素</p><p>Cocoa 经常被用于泛指所有基于 Objective－C 运行时且派生自根类(NSObject)的类或对象</p><p>Objective－C 是开发 Cocoa 和 Cocoa Touch 应用程序的本地语言. 但是 Cocoa 和 Cocoa Touch 应用程序也可以包含 C++ 和 ANSI C 代码，另外也可以使用桥接(_bridge) Objective－C 运行时的脚本语言, 例如 PyObjC 和 RubyCoco 开发 Cocoa 应用程序</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两者都包含 OC 运行时的两个核心框架:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cocoa 包含 Foundation 和 AppKit 框架, 可用于开发 Mac OS X 系统的应用程序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Cocoa" scheme="http://oneofai.com/tags/Cocoa/"/>
    
  </entry>
  
  <entry>
    <title>Cocoa 是什么</title>
    <link href="http://oneofai.com/2014/10/13/2014-10-13-cocoa-%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://oneofai.com/2014/10/13/2014-10-13-cocoa-是什么/</id>
    <published>2014-10-13T08:48:22.000Z</published>
    <updated>2018-01-15T16:11:25.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Cocoa"><a href="#一、什么是Cocoa" class="headerlink" title="一、什么是Cocoa"></a>一、什么是Cocoa</h2><h4 id="1-Cocoa-来源"><a href="#1-Cocoa-来源" class="headerlink" title="1. Cocoa 来源"></a>1. Cocoa 来源</h4><a id="more"></a> <p>1996年, <a href="https://en.wikipedia.org/wiki/Gil_Amelio" target="_blank" rel="noopener">Gil Amelio</a> 掌权的Apple正在开发 <a href="https://en.wikipedia.org/wiki/Copland_(operating_system" target="_blank" rel="noopener">Copland</a>) 操作系统, 这是 Apple 历史上最烂的产品之一. 被 Gil Amelio 雇进来的女英雄 <a href="https://en.wikipedia.org/wiki/Ellen_Hancock" target="_blank" rel="noopener">Ellen Handcock</a> 在同年8月果断放弃了 Copland, 转向从别的公司购买下一个版本的 Mac OS. 在经过调查现存的操作系统之后, Apple 公司选择了 <a href="https://en.wikipedia.org/wiki/NeXTSTEP" target="_blank" rel="noopener">NeXTSTEP</a>, 因为 NeXTSTEP很小, Apple 在1996年整个收购了 NeXT</p><p>NeXTSTEP 内置许多库和工具, 能让程序员以一种优雅的方式与窗口管理器进行交互, 这些库叫 Framework, 在1993年, NeXT 公司和 Sun 公司合作把这些 Frameworks 和工具重新修改并重命名为 OpenStep, 后来 NeXT 被 Apple 收购以后, OpenStep 被重命名为 Cocoa, 这也是为什么 Cocoa 的类都有着 NS 的前缀</p><hr><h4 id="2-何为-Cocoa"><a href="#2-何为-Cocoa" class="headerlink" title="2. 何为 Cocoa"></a>2. 何为 Cocoa</h4><p>Cocoa（iOS上叫 Cocoa Touch）是一个面向对象的软件组件——类的集成套件, 它使开发者可以快速创建健壮和全功能的 Mac OS X （iOS）应用程序</p><p>Cocoa 包含了很多框架, 其中最最核心的有两个:<br>（1）Foundation 框架</p><blockquote><p>Foundation 框架包含所有和界面显示无关的类</p></blockquote><p>（2）Application Kit（AppKit）框架（Cocoa Touch 中叫 UIKit 框架）</p><blockquote><p>Application Kit 框架包含实现图形的、事件驱动的用户界面需要的所有对象: 窗口、对话框、按键、菜单、 滚动条、文本输入框——这个列表还在不断增加</p></blockquote><p>Foundation 和 Application Kit (UIKit)框架在 Cocoa 开发中是必要的框架, 其它框架则是辅助和可选(当然也可以只用 Foundation 框架创建一个 Cocoa 程序, 而不涉及其它框架, 比如令行工具和 Internet 服务器). 和所有框架一样, 这两个框架不仅包含动态共享库(有时是几个兼容版本的库), 还包含头文件、API文档、和相关的资源   </p><p>除了这两个最核心的, Cocoa（Cocoa Touch）还有很多其他的框架, Apple 和第三方厂商也随时会发布更多的框架, 比如 Cocoa Touch 的Address Book UI框架（AddressBookUI.framework）、Game Kit框架（GameKit.framework）等等, 在开发 Cocoa 程序的时候可以按照自己的实际需求添加这些框架</p><h2 id="二、Cocoa在-Mac-OS-X-中的位置"><a href="#二、Cocoa在-Mac-OS-X-中的位置" class="headerlink" title="二、Cocoa在 Mac OS X 中的位置"></a>二、Cocoa在 Mac OS X 中的位置</h2><h4 id="1-Cocoa-在整个-Mac-OS-X-架构中的位置"><a href="#1-Cocoa-在整个-Mac-OS-X-架构中的位置" class="headerlink" title="1. Cocoa 在整个 Mac OS X 架构中的位置"></a>1. Cocoa 在整个 Mac OS X 架构中的位置</h4><p><img src="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/osx_architecture.jpg" alt="OS X"><br>上图可以看出：   </p><blockquote><p>（1）还有两个和 Cocoa 级别相同的开发框架：<a href="https://en.wikipedia.org/wiki/Carbon_(API" target="_blank" rel="noopener">Carbon</a>), <a href="https://en.wikipedia.org/wiki/Java_Development_Kit" target="_blank" rel="noopener">Java</a><br>（2）Cocoa 位于整个架构的顶端, 其下还依赖很多别的框架</p></blockquote><p>虽然 Cocoa 依赖于特定的框架, 但它并不是仅仅“坐”在这些框架的上面. 在某些情况下, Cocoa 和其它框架(比如 Carbon)是对等的, 甚至可以实现一些其它对等框架不能实现的任务. Cocoa 不仅仅是基础技术上面的一个面向对象的封装层</p><h4 id="2-另一种层级划分方式"><a href="#2-另一种层级划分方式" class="headerlink" title="2. 另一种层级划分方式"></a>2. 另一种层级划分方式</h4><p><img src="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/architecture_stack.jpg" alt="OS X"><br>上图把Mac OS X的架构分了四个部分:    </p><blockquote><p>（1）User Experience, 这个一般可以理解为 Application<br>（2）Application Frameworks, 这个理解为主要包括像 Cocoa 这样的组件<br>（3）Graphics and Media, 这个理解为 Application Service 和 Core Service<br>（4）Darwin, 这个就是 Mac OS X 的 kernel   </p></blockquote><h4 id="3-Cocoa-和其它架构的依赖关系"><a href="#3-Cocoa-和其它架构的依赖关系" class="headerlink" title="3. Cocoa 和其它架构的依赖关系"></a>3. Cocoa 和其它架构的依赖关系</h4><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febam359ckj30bm05h74t.jpg" alt=""></p><p>Cocoa 依赖的、或者通过类和方法为之提供访问通道的主要基础框架有 Core Foundation, Carbon, Core Graphics (Quartz), Launch Services, 和 Print Core (打印子系统). 详细信息如下:    </p><p><strong>（1）Core Foundation</strong></p><p>Foundation 框架的很多类都基于 Core Foundation 中对应的封装类型. 它们之间的这种紧密关系使“无损桥接”技术——即在兼容的 Core Foundation 和 Foundation 类型之间实现类型转换——成为可能. 某些 Core Foundation 的实现又基于 Darwin 层的 BSD 部分</p><p><strong>（2）Carbon</strong></p><p>Cocoa 使用了 Carbon 提供的某些服务, 因为有些 Carbon 框架在 Core Services 和 Application Services 层中定位为系统级别的服务. 作为例子, Carbon Core 就是这些框架中特别重要的一个, Cocoa 使用了它提供的 File Manager(文件管理器)组件来进行不同文件系统表示之间的转换</p><p><strong>（3）Core Graphics</strong></p><p>Cocoa 绘制和图像处理类(相当自然且紧密地)基于 Core Graphics 框架, 它实现了 Quartz 和窗口服务器组件    </p><p>Launch Services 这个 NSWorkspace 类负责向外提供 Launch Services 的潜在能力. Cocoa 还使用 Launch Services 提供的应用程序注册功能来获取与应用程序及文档相关联的图标   </p><p><strong>（4）Print Core</strong></p><p>Cocoa 的打印类是打印子系统的一个面向对象的接口</p><p>此外, Cocoa 还使用 Carbon 环境的 Text Encoding Converter(文本编码转换器)服务来处理一些字符串编码转换. 还有一些 Cocoa 方法向外提供 I/O Kit 框架、QuickDraw (QD)框架、 Apple Event (AE)框架、 和 ATS 框架的部分功能, 分别用于进行电源管理、QuickDraw 描画、 Apple Event 处理、以及提供字体 支持</p><h2 id="三、Cocoa-程序不止能通过-Objective-C-语言编写"><a href="#三、Cocoa-程序不止能通过-Objective-C-语言编写" class="headerlink" title="三、Cocoa 程序不止能通过 Objective-C 语言编写"></a>三、Cocoa 程序不止能通过 Objective-C 语言编写</h2><p>在开发 Cocoa 软件的时候, 可以使用多种编程语言. 基本, 也是官方推荐的语言是 Objective-C. OC 拥有自己 的 Cocoa 运行环境, 又是 ANSI C 的超集, 它在 ANSI C 的语法和语义特性上(从 Smalltalk 派生而来)进行扩展, 使之支持面向对象的编程, 新增的规则简单而又易于学习和使用. 由于 Objective-C 是基于 ANSI C 的, 可以自由地将 C 代码直接和 Objective-C 代码混合在一起. 而且代码可以调用非 Cocoa 的编程接口中定义的所有函数, 比如 Carbon 和 BSD. 甚至可以将 C++ 代码混合到 Cocoa 代码中, 并将它们链接在同一个执行文件中   </p><p>同时Cocoa 还支持 Java, Cocoa 为此定义了一个平行的 Java 类库, 并且实现 了一个将 Java 接口映射到 Objective-C 实现的桥机制. Cocoa 的 Java 支持使开发者可以将本地的 Java 对象 和 Cocoa 对象混合在一起使用(在某些限制下).甚至可以用PyObjC, 即 Python/Objective-C 桥来进行 Cocoa 编程. Python 是一种解释性的、注重交互的、及面向对象的编程语言. PyObjC 使 Python 对象可以向 Objective-C 对象传递消息, 就象传递给 Python 对象一样; 同时还使 Objective-C 对象可以向 Python 对象传递消息</p><h2 id="四、如何判断一个程序是不是-Cocoa-程序"><a href="#四、如何判断一个程序是不是-Cocoa-程序" class="headerlink" title="四、如何判断一个程序是不是 Cocoa 程序"></a>四、如何判断一个程序是不是 Cocoa 程序</h2><p>是什么因素使一个程序成为 Cocoa 程序? 肯定不是编程语言, 因为在 Cocoa 开发中可以使用各种语言; 也不是开发工具, 因为在命令行上就可以创建 Cocoa 程序(虽然那会使开发过程变得复杂, 且需要消耗大量时间). 那么, 所有 Cocoa 程序的共同点是什么? 是什么使它们变得与众不同?   </p><blockquote><p>因为这些程序都是由一些对象组成, 而这些对象最终都是从 NSObject 这个根类继承下来的; 还有, 这些程序都是基于 Objective-C 运行时（runtime system）环境的</p></blockquote><p>上面的说法还需要做一点限制:   </p><blockquote><p>首先, Cocoa 还有另一个根类, 即 NSProxy. 只是 NSProxy 很少用于 Cocoa 编程. 其次, 开发者可以创建自己的根类, 需要很多时间（包括编写与 Objective-C 运行时环境进行交互的代码）, 但这是可以的做到的</p></blockquote><h2 id="五、除了-Cocoa-外是否还可以使用其它框架开发-Mac-OS-X-iOS-程序"><a href="#五、除了-Cocoa-外是否还可以使用其它框架开发-Mac-OS-X-iOS-程序" class="headerlink" title="五、除了 Cocoa 外是否还可以使用其它框架开发 Mac OS X (iOS)程序"></a>五、除了 Cocoa 外是否还可以使用其它框架开发 Mac OS X (iOS)程序</h2><p>可以. 跟Cocoa处于同一级别的还有另外两个开发框架: Carbon 和 Java. 可以使用 Xcode 利用 Carbon 模版和 JDK 来进行程序开发. 只不过由于 Cocoa 的各种优点, Apple 并不推荐使用它们来进行开发工作, Carbon 模版在iOS SDK 3.1之后的 Xcode 都不再提供了, JDK的API也不再更新</p><p>参考:<br><a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/WhatIsCocoa/WhatIsCocoa.html#//apple_ref/doc/uid/TP40002974-CH3-SW16" target="_blank" rel="noopener">Cocoa Fundamentals Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是Cocoa&quot;&gt;&lt;a href=&quot;#一、什么是Cocoa&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Cocoa&quot;&gt;&lt;/a&gt;一、什么是Cocoa&lt;/h2&gt;&lt;h4 id=&quot;1-Cocoa-来源&quot;&gt;&lt;a href=&quot;#1-Cocoa-来源&quot; class=&quot;headerlink&quot; title=&quot;1. Cocoa 来源&quot;&gt;&lt;/a&gt;1. Cocoa 来源&lt;/h4&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="http://oneofai.com/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="http://oneofai.com/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Cocoa" scheme="http://oneofai.com/tags/Cocoa/"/>
    
  </entry>
  
</feed>
