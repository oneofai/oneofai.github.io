<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon180*180.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32*32.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16*16.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">





  <meta name="keywords" content="ONEOFAI, iOS, iOS开发" />




  


  <link rel="alternate" href="/atom.xml" title="YG's Blog" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="sitemap">
<meta property="og:url" content="http://oneofai.com/sitemap/index.html">
<meta property="og:site_name" content="YG&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-15T16:27:30.404Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sitemap">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '43XARCY75U',
      apiKey: 'bf6158f5b87eee26732adfce4f73b39a',
      indexName: 'blogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"我们没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}
    }
  };
</script>



  <link rel="canonical" href="http://oneofai.com/sitemap/"/>





  <title>Objective-C Runtime | YG's Blog</title>
  








  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YG's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://oneofai.com/2015/04/21/2015-04-21-objective-c-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ONEOFAI">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YG's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Objective-C Runtime</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-21T10:15:29+08:00">2015-04-21</time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS开发/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文转自杨萧玉博客: <a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime" target="_blank" rel="noopener">玉令天下</a></p>
</blockquote>
<p>本文详细整理了 <strong>Cocoa</strong> 的 <strong>Runtime</strong> 系统的知识, 它使得 <strong>Objective-C</strong> 如虎添翼, 具备了灵活的动态特性, 使这门古老的语言焕发生机</p>
<a id="more"></a> 
<p>主要内容如下:</p>
<hr>
<ul>
<li><strong><a href="#introduction">引言</a></strong></li>
<li><strong><a href="#intro">简介</a></strong></li>
<li><strong><a href="#interaction_with_runtime">与Runtime交互</a></strong></li>
<li><strong><a href="#runtime_jargon">Runtime术语</a></strong></li>
<li><strong><a href="#message">消息</a></strong></li>
<li><strong><a href="#dynamic_method_parse">动态方法解析</a></strong></li>
<li><strong><a href="#message_forward">消息转发</a></strong></li>
<li><strong><a href="#robust_instance">健壮的实例变量(Non Fragile ivars)</a></strong></li>
<li><strong><a href="#objc_Associated_obj">Objective-C Associated Objects</a></strong></li>
<li><strong><a href="#method-swizzling">Method Swizzling</a></strong></li>
<li><strong><a href="#summary">总结</a></strong></li>
</ul>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><span id="introduction">引言</span></h2><p>曾经觉得Objective-C特别方便上手, 面对着 Cocoa 中大量 API, 只知道简单的查文档和调用. 还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单的方法调用, 而无视了 <strong>“发送消息”</strong> 这句话的深刻含义. 于是<code>[receiver message]</code>会被编译器转化为:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure></p>
<p>如果消息含有参数, 则为:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果消息的接收者能够找到对应的<code>selector</code>, 那么就相当于直接执行了接收者这个对象的特定方法;  否则, 消息要么被转发, 或是临时向接收者动态添加这个<code>selector</code> 对应的实现内容, 要么就干脆玩完崩溃掉</li>
<li>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用. 因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息, 而<code>receive</code>将要如何响应这条消息, 那就要看运行时发生的情况来决定了</li>
<li><strong>Objective-C</strong> 的 <strong>Runtime</strong> 铸就了它动态语言的特性, 这些深层次的知识虽然平时写代码用的少一些, 但是却是每个 <strong>Objective-C</strong> 程序员需要了解的   </li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span id="intro">简介</span></h2><p>因为 <strong>Objective-C</strong> 是一门动态语言, 所以它总是想办法把一些决定工作从编译连接推迟到运行时. 也就是说只有编译器是不够的, 还需要一个运行时系统 (<code>runtime system</code>) 来执行编译后的代码. 这就是 <strong>Objective-C Runtime</strong> 系统存在的意义, 它是整个Objc运行框架的一块基石</p>
<p><strong>Runtime</strong> 其实有两个版本:“modern”和 “legacy”. 我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统, 只能运行在 iOS 和 OS X 10.5 之后的64位程序中. 而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统. <code>这两个版本最大的区别在于当你更改一个类的实例变量的布局时, 在早期版本中你需要重新编译它的子类, 而现行版就不需要</code></p>
<p>Runtime基本是 <strong>C和汇编</strong> 写的, 可见苹果为了动态系统的高效而作出的努力. 你可以在<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码. 苹果和GNU各自维护一个开源的Runtime版本, 这两个版本之间都在努力的保持一致</p>
<h2 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a><span id="interaction_with_runtime">与Runtime交互</span></h2><p>Objectie-C 从三种不同的层级上与 Runtime 系统进行交互, 分别是通过 Objective-C 源代码, 通过 <code>Foundation</code> 框架的 <code>NSObject</code> 类定义的方法, 通过对 runtime 函数的直接调用</p>
<h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行, Runtime 系统自动在幕后辛勤劳作着. 还记得引言中举的例子吧, 消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数, Objective-C中的类、方法和协议等在 Runtime 中都由一些数据结构来定义, 这些内容在后面会讲到. （比如 <code>objc_msgSend</code> 函数及其参数列表中的 <code>id</code> 和 <code>SEL</code> 都是啥）</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa 中大多数类都继承于 NSObject 类, 也就自然继承了它的方法. 最特殊的例外是 NSProxy , 它是个抽象超类, 它实现了一些消息转发有关的方法, 可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类, 说白了就是领导把自己展现给大家风光无限, 但是把活儿都交给幕后小弟去干</p>
<p>有的 NSObject 中的方法起到了抽象接口的作用, 比如 description 方法需要你重载它并为你定义的类提供描述内容. NSObject 还有些方法能在运行时获得类的信息, 并检查一些特性, 比如 class 返回对象的类; <code>isKindOfClass:</code> 和<code>isMemberOfClass:</code> 则检查对象是否在指定的类继承体系中; <code>respondsToSelector:</code> 检查对象能否响应指定的消息; <code>conformsToProtocol:</code> 检查对象是否实现了指定协议类的方法; <code>methodForSelector:</code>则返回指定方法实现的地址</p>
<h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成, 具有公共接口的动态共享库. 头文件存放于<code>/usr/include/objc</code> 目录下. 许多函数允许你用纯C代码来重复实现 Objc 中同样的功能. 虽然有一些方法构成了 NSObject 类的基础, 但是你在写 Objc 代码时一般不会直接用到这些函数的, 除非是写一些 Objc 与其他语言的桥接或是底层的debug工作. 在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档</p>
<h2 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a><span id="runtime_jargon">Runtime术语</span></h2><p>还记得引言中的 <code>objc_msgSend:</code>方法吧, 它的真身是这样的:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend ( <span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ... );</span><br></pre></td></tr></table></figure></p>
<p>下面将会逐渐展开介绍一些术语, 其实它们都对应着数据结构</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code> 函数第二个参数类型为SEL , 它是selector 在Objc中的表示类型（Swift中是Selector类）. selector 是方法选择器, 可以理解为区分方法的 ID, 而这个 ID 的数据结构是SEL:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>其实它就是个映射到方法的C字符串, 你可以用 Objc 编译器命令<code>@selector()</code> 或者 Runtime 系统的  <code>sel_registerName</code>函数来获得一个SEL 类型的方法选择器<br>不同类中相同名字的方法所对应的方法选择器是相同的, 即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器, 于是 Objc 中方法命名有时会带上参数类型( <code>NSNumber</code> 一堆抽象工厂方法拿走不谢), Cocoa 中有好多长长的方法哦</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code> 第一个参数类型为id, 大家对它都不陌生, 它是一个指向类实例的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>那 <code>objc_object</code> 又是啥呢:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>objc_object</code> 结构体包含一个isa指针, 根据isa指针就可以顺藤摸瓜找到对象所属的类</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说isa是指针是因为Class其实是一个指向<code>objc_class</code>结构体的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<p>而<code>objc_class</code>就是我们摸到的那个瓜, 里面的东西多着呢:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name</span><br><span class="line">    <span class="keyword">long</span> version</span><br><span class="line">    <span class="keyword">long</span> info</span><br><span class="line">    <span class="keyword">long</span> instance_size</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols</span><br><span class="line"><span class="meta">#endif         </span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<p>可以看到运行时一个类还关联了它的超类指针, 类名, 成员变量, 方法, 缓存, 还有附属的协议.  其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">     <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete</span><br><span class="line">    <span class="keyword">int</span> method_count</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">     <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你C语言不是特别好, 可以直接理解为<code>objc_ivar_list</code>结构体存储<code>objc_ivar</code> 数组列表, 而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息; 同理<code>objc_method_list</code> 结构体存储着<code>objc_method</code>数组列表, 而<code>objc_method</code>结构体存储了类的某个方法的信息</p>
<p>最后要提到的还有一个<code>objc_cache</code>, 顾名思义它是缓存, 它在<code>objc_class</code>的作用很重要, 在后面会讲到</p>
<p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象, 这是因为一个 ObjC 类本身同时也是一个对象, 为了处理类和对象的关系, runtime 库创建了一种叫做元类 (Meta Class) 的东西, 类对象所属类型就叫做元类, 它用来表述类对象本身所具备的元数据. 类方法就定义于此处, 因为这些方法可以理解成类对象的实例方法每个类仅有一个类对象, 而每个类对象仅有一个与之相关的元类. 当你发出一个类似<code>[NSObject alloc]</code>的消息时, 你事实上是把这个消息发给了一个类对象 (Class Object) , 这个类对象必须是一个元类的实例, 而这个元类同时也是一个根元类 (root meta class) 的实例</p>
<p>你会说 NSObject 的子类时, 你的类就会指向NSObject 做为其超类. 但是所有的元类最终都指向根元类为其超类. 所有的元类的方法列表都有能够响应消息的类方法. 所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候, <code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法, 如果找到了, 然后对这个类对象执行方法调用</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1febgap6hr9j30fa0fzta4.jpg" alt="struct"></p>
<p>上图实线是 <code>super_class</code> 指针, 虚线是<code>isa</code>指针.  有趣的是根元类的超类是NSObject, 而<code>isa</code>指向了自己, 而NSObject的超类为nil, 也就是它没有超类</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method是一种代表类中的某个方法的类型<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br></pre></td></tr></table></figure></p>
<p>而<code>objc_method</code>在上面的方法列表中提到过, 它存储了方法名, 方法类型和方法实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name</span><br><span class="line">    <span class="keyword">char</span> *method_types</span><br><span class="line">    IMP method_imp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>方法名类型为<code>SEL</code>, 前面提到过相同名字的方法即使在不同类中定义, 它们的方法选择器也相同</p>
</li>
<li><p>方法类型<code>method_types</code>是个char指针, 其实存储着方法的参数类型和返回值类型</p>
</li>
<li><code>method_imp</code>指向了方法的实现, 本质上是一个函数指针, 后面会详细讲到</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar是一种代表类中实例变量的类型<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br></pre></td></tr></table></figure></p>
<p>而<code>objc_ivar</code>在上面的成员变量列表中也提到过:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name</span><br><span class="line">    <span class="keyword">char</span> *ivar_type</span><br><span class="line">    <span class="keyword">int</span> ivar_offset</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS: <code>OBJC2_UNAVAILABLE</code> 之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法, 有兴趣的可以<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">查看源码</a></p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP在<code>objc.h</code>中的定义是:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br></pre></td></tr></table></figure></p>
<p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">函数指针</a>, 这是由编译器生成的. 当你发起一个 <code>ObjC</code> 消息之后, 最终它会执行的那段代码, 就是由这个函数指针指定的. 而 IMP 这个函数指针就指向了这个方法的实现. 既然得到了执行某个实例某个方法的入口, 我们就可以绕开消息传递阶段, 直接执行方法, 这在后面会提到</p>
<p>你会发现IMP指向的方法与<code>objc_msgSend</code>函数类型相同, 参数都包含<code>id</code>和<code>SEL</code>类型. 每个方法名都对应一个<code>SEL</code>类型的方法选择器, 而每个实例对象中 <code>SEL</code>对应的方法实现肯定是唯一的, 通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址; 反之亦然</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在<code>runtime.h</code>中Cache的定义如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br></pre></td></tr></table></figure></p>
<p>还记得之前<code>objc_class</code>结构体中有一个<code>struct objc_cache *cache</code>吧, 它到底是缓存啥的呢, 先看看<code>objc_cache</code>的实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied</span><br><span class="line">    Method buckets[<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Cache</code>为方法调用的性能进行优化, 通俗地讲, 每当实例对象接收到一个消息时, 它不会直接在<code>isa</code>指向的类的方法列表中遍历查找能够响应消息的方法, 因为这样效率太低了, 而是优先在Cache中查找. Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用, 那么它有可能今后还会被调用）, 下次查找的时候效率更高. 这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像, 而我猜苹果为提高Cache命中率应该也做了努力吧</p>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p><code>@property</code>标记了类中的属性, 这个不必多说大家都很熟悉, 它是一个指向<code>objc_property</code>结构体的指针:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;<span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code>方法来获取类和协议中的属性:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure></p>
<p>返回类型为指向指针的指针, 哈哈, 因为属性列表是个数组, 每个元素内容都是一个<code>objc_property_t</code>指针, 而这两个函数返回的值是指向这个数组的指针   </p>
<p>举个栗子, 先声明一个类:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>你可以用下面的代码获取属性列表:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure></p>
<p>你可以用<code>property_getName</code>函数来查找属性名称:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>你可以用<code>class_getProperty</code> 和 <code>protocol_getProperty</code>通过给出的名称来在类和协议中获取属性的引用:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty)</span><br></pre></td></tr></table></figure></p>
<p>你可以用<code>property_getAttributes</code>函数来发掘属性的名称和<code>@encode</code>类型字符串:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure></p>
<p>把上面的代码放一起, 你就能从一个类中获取它的属性啦:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++)&#123;</span><br><span class="line">    objc_property_t property = properties[i];    </span><br><span class="line">    printf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a><span id="message">消息</span></h2><p>前面做了这么多铺垫, 现在终于说到了消息了. Objc 中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来, 而直到运行时才会把消息与方法实现绑定</p>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在引言中已经对<code>objc_msgSend</code>进行了一点介绍, 看起来像是<code>objc_msgSend</code>返回了数据, 其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据</p>
<p>下面详细叙述下消息发送步骤:</p>
<ol>
<li>检测这个 <code>selector</code> 是不是要忽略的. 比如 Mac OS X 开发, 有了垃圾回收就不理会 retain,release 这些函数了   </li>
<li>检测这个 target 是不是 nil 对象. ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash, 因为会被忽略掉</li>
<li>如果上面两个都过了, 那就开始查找这个类的 IMP, 先从 cache 里面找, 完了找得到就跳到对应的函数去执行</li>
<li>如果 cache 找不到就找一下方法分发表</li>
<li>如果分发表找不到就到超类的分发表去找, 一直找, 直到找到NSObject 类为止</li>
<li>如果还找不到就要开始进入<code>动态方法</code>解析了, 后面会提到</li>
</ol>
<p>PS:这里说的分发表其实就是<code>Class</code>中的方法列表, 它将方法选择器和方法实现地质联系起来<br><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""><br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或<code>objc_msgSendSuper_stret</code> 四个方法中选择一个来调用. 如果消息是传递给超类, 那么会调用名字带有”Super”的函数; 如果消息返回值是数据结构而不是简单值时, 那么会调用名字带有”stret”的函数. 排列组合正好四个方法</p>
<p>值得一提的是在 i386 平台处理返回类型为浮点数的消息时, 需要用到<code>objc_msgSend_fpret</code>函数来进行处理, 这是因为返回类型为浮点数的函数对应的 ABI(Application Binary Interface) 与返回整型的函数的 ABI 不兼容. 此时<code>objc_msgSend</code>不再适用, 于是<code>objc_msgSend_fpret</code>被派上用场, 它会对浮点数寄存器做特殊处理. 不过在 PPC 或 PPC64 平台是不需要麻烦它的</p>
<p>PS: 有木有发现这些函数的命名规律哦? 带“Super”的是消息传递给超类; “stret”可分为“st”+“ret”两部分, 分别代表“struct”和“return”; “fpret”就是“fp”+“ret”, 分别代表“floating-point”和“return”</p>
<h4 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h4><p>我们经常在方法中使用<code>self</code>关键字来引用实例本身, 但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧. 其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的   </p>
<p>当<code>objc_msgSend</code>找到方法对应的实现时, 它将直接调用该方法实现, 并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数. 它们是在代码被编译时被插入实现中的. 尽管这些参数没有被明确声明, 在源代码中我们仍然可以引用它们. 在下面的例子中, <code>self</code>引用了接收者对象, 而<code>_cmd</code>引用了方法本身的选择器:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个参数中, <code>self</code> 更有用. 实际上,它是在方法实现中访问消息接收者对象的实例变量的途径<br>而当使用<code>[super XXXX]</code> 调用时, 会使用 <code>objc_msgSendSuper</code> 函数, 看下 objc_msgSendSuper 的函数定义:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是个<code>objc_super</code>的结构体, 第二个参数还是类似上面的类方法的<code>selector</code>, 先看下objc_super这个结构体是什么东西:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">id</span> receiver;</span><br><span class="line">     Class superClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到这个结构体包含了两个成员, 一个是 receiver, 这个类似上面 <code>objc_msgSend</code> 的第一个参数 receiver, 第二个成员是记录写 super 这个类的父类是什么, 拿上面的代码为例, 当编译器遇到 PersonMe 里<code>setName:andAge</code> 方法里的 <code>[super setName:]</code> 时, 开始做这几个事: 构建 <code>objc_super</code> 的结构体, 此时这个结构体的第一个成员变量 <code>receiver</code> 就是 <code>PersonMe *me</code>, 和 <code>self</code> 相同. 而第二个成员变量 <code>superClass</code> 就是指类 <code>Person</code>, 因为 <code>PersonMe</code> 的超类就是这个 Person</p>
<p>调用 <code>objc_msgSendSuper</code> 的方法, 将这个结构体和 <code>setName</code> 的 <code>sel</code> 传递过去. 函数里面在做的事情类似这样: 从 <code>objc_super</code> 结构体指向的 <code>superClass</code>的方法列表开始找 <code>setName</code> 的 <code>selector</code>, 找到后再以 <code>objc_super-&gt;receiver</code> 去调用这个 <code>selector</code>, 可能也会使用 <code>objc_msgSend</code> 这个函数, 不过此时的第一个参数 <code>theReceiver</code> 就是 <code>objc_super-&gt;receiver</code>, 第二个参数是从 <code>objc_super-&gt;superClass</code> 中找到的 <code>selector</code></p>
<p>例如:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"self ' class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"super' class is %@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure></p>
<p>而当方法中的<code>super</code>关键字接收到消息时, 编译器会创建一个<code>objc_super</code>结构体:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> receiver;</span><br><span class="line">    Class <span class="keyword">class</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体指明了消息应该被传递给特定超类的定义. 但<code>receiver</code>仍然是<code>self</code>本身, 这点需要注意, 因为当我们想通过<code>[super class]</code> 获取超类时, 编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数, 因为只有在<code>NSObject</code>类找到<code>class</code>方法, 然后<code>class</code>方法调用<code>object_getClass()</code>, 接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>, 传入的第一个参数是指向<code>self</code>的<code>id</code>指针, 与调用<code>[self class]</code>相同, 所以我们得到的永远都是<code>self</code>的类型</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在<code>IMP</code>那节提到过可以避开消息绑定而直接获取方法的地址并调用方法. 这种做法很少用, 除非是需要持续大量重复调用某方法的极端情况, 避开消息发送泛滥而直接调用该方法会更高效.<br><code>NSObject</code>类中有个<code>methodForSelector:</code>实例方法, 你可以用它来获取某个方法选择器对应的IMP, 举个栗子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))</span><br><span class="line">    [target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure>
<p>当方法被当做函数调用时, 上节提到的两个隐藏参数就需要我们明确给出了. 上面的例子调用了1000次函数, 你可以试试直接给<code>target</code>发送1000次<code>setFilled:</code>消息会花多久<br>PS: <code>methodForSelector:</code>方法是由 Cocoa 的 Runtime 系统提供的, 而不是 Objc 自身的特性</p>
<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a><span id="dynamic_method_parse">动态方法解析</span></h2><p>你可以动态地提供一个方法的实现. 例如我们可以用@dynamic    </p>
<p>关键字在类的实现文件中修饰一个属性:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure></p>
<p>这表明我们会为这个属性动态提供存取方法, 也就是说编译器不会再默认为我们生成<code>setPropertyName:</code>和<code>propertyName</code>方法, 而需要我们动态提供. 我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现. 因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时, Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会. 我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically))</span><br><span class="line">    &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容, 也就是dynamicMethodIMP方法中的代码. 其中 “v@: ” 表示返回值和参数, 这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p>
<p>PS: 动态方法解析会在消息转发机制侵入前执行. 如果 <code>respondsToSelector:</code> 或<code>instancesRespondToSelector:</code> 方法被执行, 动态方法解析器将会被首先给予一个提供该方法选择器对应的 IMP 的机会. 如果你想让该方法选择器被传送到转发机制, 那么就让<code>resolveInstanceMethod:</code> 返回NO</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a><span id="message_forward">消息转发<span></span></span></h2><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febh76h7jnj30m80h6ab1.jpg" alt=""></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前, Runtime 系统会再给我们一次偷梁换柱的机会, 即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>毕竟消息转发要耗费更多时间, 抓住这次机会将消息重定向给别人是个不错的选择, 不过千万别返回self, 因为那样会死循环   </p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回NO 时, 消息转发机制会被触发. 在这时<code>forwardInvocation:</code> 方法会被执行, 我们可以重写这个方法来定义我们的转发逻辑:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector: [anInvocation selector]])     </span><br><span class="line">    &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该消息的唯一参数是个NSInvocation 类型的对象——该对象封装了原始的消息和消息的参数. 我们可以实现<code>forwardInvocation:</code> 方法来对不能处理的消息做一些默认的处理, 也可以将消息转发给其他对象来处理, 而不抛出错误</p>
<p>这里需要注意的是参数anInvocation 是从哪的来的呢？其实在<code>forwardInvocation:</code> 消息发送前, Runtime系统会向对象发送<code>methodSignatureForSelector:</code> 消息, 并取到返回的方法签名用于生成NSInvocation 对象. 所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code> 方法, 否则会抛异常</p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时, 运行时系统将通过<code>forwardInvocation:</code>消息通知该对象. 每个对象都从NSObject类中继承了<code>forwardInvocation:</code>方法. 然而, NSObject中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>. 通过实现我们自己的<code>forwardInvocation:</code>方法, 我们可以在该方法实现中将消息转发给其它对象</p>
<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心, 将这些消息转发给不同接收对象. 或者它也可以象一个运输站将所有的消息都发送给同一个接收对象. 它可以将一个消息翻译成另外一个消息, 或者简单的”吃掉“某些消息, 因此没有响应也没有错误. <code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应, 这一切都取决于方法的具体实现. 该方法所提供是将不同的对象链接到消息链的能力</p>
<p>注意:  </p>
<blockquote>
<p><code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用.  所以, 如果我们希望一个对象将negotiate消息转发给其它对象, 则这个对象不能有negotiate方法. 否则, <code>forwardInvocation:</code>将不可能会被调用</p>
</blockquote>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似, 可以用于为Objc编程添加一些多继承的效果. 就像下图那样, 一个对象把消息转发出去, 就好似它把另一个对象中的方法借过来或是“继承”过来一样</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="">     </p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法, 在上图中Warrior和Diplomat没有继承关系, 但是Warrior将negotiate消息转发给了Diplomat后, 就好似Diplomat是Warrior的超类一样</p>
<p>消息转发弥补了 Objc 不支持多继承的性质, 也避免了因为多继承导致单个类变得臃肿复杂. 它将问题分解得很细, 只针对想要借鉴的方法才转发, 而且转发机制是透明的</p>
<h4 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h4><p>转发不仅能模拟多继承, 也能使轻量级对象代表重量级对象. 弱小的女人背后是强大的男人, 毕竟女人遇到难题都把它们转发给男人来做了. 这里有一些适用案例, 可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="noopener">官方文档</a></p>
<h4 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h4><p>尽管转发很像继承, 但是NSObject类不会将两者混淆<br>像<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>这类方法只会考虑继承体系, 不会考虑转发链. 比如上图中一个Warrior对象如果被问到是否能响应negotiate<br>消息:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<p>结果是NO, 尽管它能够接受negotiate消息而不报错, 因为它靠转发消息给Diplomat类来响应消息</p>
<p>如果你为了某些意图偏要“弄虚作假”让别人以为Warrior继承到了Diplomat的negotiate方法, 你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>来加入你的转发算法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Here, test whether the aSelector message can</span></span><br><span class="line"><span class="comment">       be forwarded to another object and whether that object can respond to it.</span></span><br><span class="line"><span class="comment">       Return YES if it can.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>之外, <code>instancesRespondToSelector:</code>中也应该写一份转发算法. 如果使用了协议, <code>conformsToProtocol:</code>同样也要加入到这一行列中. 类似地, 如果一个对象转发它接受的任何远程消息, 它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述, 这个方法会最终响应被转发的消息. 比如一个对象能给它的替代者对象转发消息, 它需要像下面这样实现<code>methodSignatureForSelector:</code>:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">   <span class="keyword">if</span> (!signature)&#123;</span><br><span class="line">        signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a><span id="robust_instance">健壮的实例变量(Non Fragile ivars)</span></h2><p>在 Runtime 的现行版本中, 最大的特点就是健壮的实例变量. 当一个类被编译时, 实例变量的布局也就形成了, 它表明访问类的实例变量的位置. 从对象头部开始, 实例变量依次根据自己所占空间而产生位移:</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febhe6p56sj30cc039q36.jpg" alt=""></p>
<p>上图左边是NSObject类的实例变量布局, 右边是我们写的类的布局, 也就是在超类后面加上我们自己类的实例变量, 看起来不错. 但试想如果那天苹果更新了NSObject 类, 发布新版本的系统的话, 那就悲剧了:</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1febhejwsvcj30cf03cmxk.jpg" alt=""></p>
<p>我们自定义的类被划了两道线, 那是因为那块区域跟超类重叠了. 唯有苹果将超类改为以前的布局才能拯救我们, 但这样也导致它们不能再拓展它们的框架了, 因为成员变量布局被死死地固定了. 在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性. 那么在健壮的实例变量下回发生什么呢？</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1febhewc7doj30ci04rdge.jpg" alt=""></p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样, 但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移, 那样你在子类中新添加的成员就被保护起来了</p>
<p>需要注意的是在健壮的实例变量下, 不要使用<code>sizeof(SomeClass)</code>, 而是用<code>class_getInstanceSize([SomeClass class])</code>代替; 也不要使用<code>offsetof(SomeClass, SomeIvar)</code>, 而要用<code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code>来代替</p>
<h2 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a><span id="objc_Associated_obj">Objective-C Associated Objects</span></h2><p>在 OS X 10.6 之后, Runtime系统让Objc支持向对象动态添加变量. 涉及到的函数有以下三个:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</span><br></pre></td></tr></table></figure></p>
<p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值. 其中关联政策是一组枚举常量:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,         </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,            </span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这些常量对应着引用关联值的政策, 也就是 Objc 内存管理的引用计数机制</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a><span id="method-swizzling">Method Swizzling</span></h2><p>之前所说的消息转发虽然功能强大, 但需要我们了解并且能更改对应类的源代码, 因为我们需要实现自己的转发逻辑. 当我们无法触碰到某个类的源代码, 却想更改这个类某个方法的实现时, 该怎么办呢？可能继承类并重写方法是一种想法, 但是有时无法达到目的. 这里介绍的是 Method Swizzling , 它通过重新映射方法对应的实现来达到“偷天换日”的目的. 跟消息转发相比, Method Swizzling 的做法更为隐蔽, 甚至有些冒险, 也增大了debug的难度</p>
<p>这里摘抄一个 NSHipster 的例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">       <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">       <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">      <span class="keyword">if</span> (didAddMethod)</span><br><span class="line">      &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">   [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码通过添加一个Tracking 类别到UIViewController类中,  UIViewController 类的<code>viewWillAppear:</code> 方法和Tracking 类别中<code>xxx_viewWillAppear:</code> 方法的实现相互调换. Swizzling 应该在+load 方法中实现, 因为+load 是在一个类最开始加载时调用. dispatch_once 是GCD中的一个方法, 它保证了代码块只执行一次, 并让其为一个原子操作, 线程安全是很重要的</p>
<p>先用<code>class_addMethod</code>和<code>class_replaceMethod</code>函数将两个方法的实现进行调换, 如果类中已经有了<code>viewWillAppear:</code>方法的实现, 那么就调用<code>method_exchangeImplementations</code> 函数交换了两个方法的IMP, 这是苹果提供给我们用于实现 Method Swizzling 的便捷方法.</p>
<p>可能有人注意到了这行:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line"><span class="comment">// Class aClass = object_getClass((id)self);</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></span><br><span class="line"><span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></span><br></pre></td></tr></table></figure>
<p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 Class,但前者为元类, 后者为其本身, 因为此时 self 为 Class 而不是实例.注意 <code>[NSObject class]</code> 与 <code>[object class]</code> 的区别：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:如果类中没有想被替换实现的原方法时, <code>class_replaceMethod</code> 相当于直接调用 <code>class_addMethod</code> 向类中添加该方法的实现, 否则调用<code>method_setImplementation</code>方法, <code>types</code>参数会被忽略. <code>method_exchangeImplementations</code> 方法做的事情与如下的原子操作等价:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = method_getImplementation(m1);</span><br><span class="line">IMP imp2 = method_getImplementation(m2);</span><br><span class="line">method_setImplementation(m1, imp2);</span><br><span class="line">method_setImplementation(m2, imp1);</span><br></pre></td></tr></table></figure>
<p>最后<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环, 其实不会的. 因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现, 而它的实现已经被我们<code>viewWillAppear:</code>方法实现进行了互换, 所以这段代码不仅不会死循环, 如果你把<code>[self xxx_viewWillAppear:animated]</code>换成<code>[self viewWillAppear:animated]</code>反而会引发死循环</p>
<p>看到有人说<code>+load</code>方法本身就是线程安全的, 因为它在程序刚开始就被调用, 很少会碰到并发问题, 于是 StackOverFlow 上也有大神给出了另一个 Method Swizzling 的实现:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 is %@"</span>, arg1); [<span class="keyword">self</span> replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</span><br><span class="line">    SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">    Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod)))</span><br><span class="line">    &#123;</span><br><span class="line">       class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码同样要添加在某个类的类别中, 相比第一个种实现, 只是去掉了<code>dispatch_once</code> 部分. Method Swizzling 的确是一个值得深入研究的话题, Method Swizzling 的最佳实现是什么呢？小弟才疏学浅理解的不深刻, 找了几篇不错的资源推荐给大家:</p>
<p><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">JRSwizzle</a><br><a href="http://nshipster.com/method-swizzling" target="_blank" rel="noopener">Method Swizzling</a><br><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Objective-C的hook方案（一）: Method Swizzling</a><br><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="noopener">How do I implement method swizzling?</a><br><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a>   </p>
<p>在用 SpriteKit 写游戏的时候, 因为 API 本身有一些缺陷(增删节点时不考虑父节点是否存在啊, 很容易崩溃啊有木有!), 我在 Swift 上使用 Method Swizzling弥补这个缺陷:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleAddChild</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">"addChild:"</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">"yxy_addChild:"</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleRemoveFromParent</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">"removeFromParent"</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">"yxy_removeFromParent"</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">yxy_addChild</span><span class="params">(node: SKNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.yxy_addChild(node)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"This node has already a parent!\(node.name)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">yxy_removeFromParent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent != <span class="literal">nil</span> &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.yxy_removeFromParent()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"This node has no parent!\(name)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后其他地方调用那两个类方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SKNode.yxy_swizzleAddChild()</span><br><span class="line">SKNode.yxy_swizzleRemoveFromParent()</span><br></pre></td></tr></table></figure></p>
<p>因为 Swift 中的 extension 的特殊性, 最好在某个类的 `load()`` 方法中调用上面的两个方法. 我是在AppDelegate 中调用的, 于是保证了应用启动时能够执行上面两个方法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="summary">总结</span></h2><p>我们之所以让自己的类继承NSObject 不仅仅因为苹果帮我们完成了复杂的内存分配问题, 更是因为这使得我们能够用上 Runtime 系统带来的便利. 可能我们平时写代码时可能很少会考虑一句简单的<code>[receiver message]</code> 背后发生了什么, 而只是当做方法或函数调用. 深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码, 比如 Method Swizzling 等   </p>
<p>参考链接:<br><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="noopener">Objective-C runtime之运行时的基本特点</a><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming  Guide</a><br><a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">Understanding the Objective-C Runtime</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ONEOFAI
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://oneofai.com/2015/04/21/2015-04-21-objective-c-runtime/" title="Objective-C Runtime">http://oneofai.com/2015/04/21/2015-04-21-objective-c-runtime/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS-开发/" rel="tag"># iOS 开发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/04/10/2015-04-10-制作自己的-pods-依赖库/" rel="next" title="制作自己的 Pods 依赖库">
                <i class="fa fa-chevron-left"></i> 制作自己的 Pods 依赖库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/15/2015-05-15-uitableview-上下滑动控制底部按钮的出现和消失/" rel="prev" title="UITableView 上下滑动控制底部按钮的出现和消失">
                UITableView 上下滑动控制底部按钮的出现和消失 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="ONEOFAI" />
            
              <p class="site-author-name" itemprop="name">ONEOFAI</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/oneofai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:holaux@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/oneofai" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/oneoai" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与Runtime交互"><span class="nav-number">3.</span> <span class="nav-text">与Runtime交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Objective-C源代码"><span class="nav-number">3.0.1.</span> <span class="nav-text">Objective-C源代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSObject的方法"><span class="nav-number">3.0.2.</span> <span class="nav-text">NSObject的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime的函数"><span class="nav-number">3.0.3.</span> <span class="nav-text">Runtime的函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime术语"><span class="nav-number">4.</span> <span class="nav-text">Runtime术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SEL"><span class="nav-number">4.0.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#id"><span class="nav-number">4.0.2.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class"><span class="nav-number">4.0.3.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method"><span class="nav-number">4.0.4.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ivar"><span class="nav-number">4.0.5.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMP"><span class="nav-number">4.0.6.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache"><span class="nav-number">4.0.7.</span> <span class="nav-text">Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Property"><span class="nav-number">4.0.8.</span> <span class="nav-text">Property</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息"><span class="nav-number">5.</span> <span class="nav-text">消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend函数"><span class="nav-number">5.0.1.</span> <span class="nav-text">objc_msgSend函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法中的隐藏参数"><span class="nav-number">5.0.2.</span> <span class="nav-text">方法中的隐藏参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取方法地址"><span class="nav-number">5.0.3.</span> <span class="nav-text">获取方法地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态方法解析"><span class="nav-number">6.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息转发"><span class="nav-number">7.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重定向"><span class="nav-number">7.0.1.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转发"><span class="nav-number">7.0.2.</span> <span class="nav-text">转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转发和多继承"><span class="nav-number">7.0.3.</span> <span class="nav-text">转发和多继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#替代者对象-Surrogate-Objects"><span class="nav-number">7.0.4.</span> <span class="nav-text">替代者对象(Surrogate Objects)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转发与继承"><span class="nav-number">7.0.5.</span> <span class="nav-text">转发与继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#健壮的实例变量-Non-Fragile-ivars"><span class="nav-number">8.</span> <span class="nav-text">健壮的实例变量(Non Fragile ivars)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C-Associated-Objects"><span class="nav-number">9.</span> <span class="nav-text">Objective-C Associated Objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">10.</span> <span class="nav-text">Method Swizzling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ONEOFAI</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.0.1"></script>



  

  

  

  
  

  

  

  

</body>
</html>
